{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>TODO</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>hya</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>hya</code> to a new version will possibly break any code that was using the old version of <code>hya</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>hya</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install feu\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>feu</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'feu[all]'\n</code></pre> <p>This command also installed PyTorch. It is also possible to install the optional packages manually or to select the packages to install.</p> <pre><code>pip install feu torch\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>feu</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/feu.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate feu\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>feu</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/git/","title":"Git","text":""},{"location":"refs/git/#feu.git","title":"feu.git","text":"<p>Contain git utility functions.</p>"},{"location":"refs/git/#feu.git.get_last_tag_name","title":"feu.git.get_last_tag_name","text":"<pre><code>get_last_tag_name() -&gt; str\n</code></pre> <p>Get the name of the most recent tag in the current repository.</p> <p>Returns:</p> Type Description <code>str</code> <p>The tag name.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.git import get_last_tag_name\n&gt;&gt;&gt; tag = get_last_tag_name()\n&gt;&gt;&gt; tag\n</code></pre>"},{"location":"refs/git/#feu.git.get_last_version_tag_name","title":"feu.git.get_last_version_tag_name","text":"<pre><code>get_last_version_tag_name() -&gt; str\n</code></pre> <p>Get the name of the most recent version tag in the current repository.</p> <p>A version tag is a tag starting with <code>v{number}*</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>The tag name.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.git import get_last_version_tag_name\n&gt;&gt;&gt; tag = get_last_version_tag_name()\n&gt;&gt;&gt; tag\n</code></pre>"},{"location":"refs/git/#feu.git.get_tags","title":"feu.git.get_tags","text":"<pre><code>get_tags() -&gt; list[TagReference]\n</code></pre> <p>Get the list of git tags sorted by date/time for the current repository.</p> <p>Returns:</p> Type Description <code>list[TagReference]</code> <p>The list of git tags sorted by date/time.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.git import get_tags\n&gt;&gt;&gt; tags = get_tags()\n&gt;&gt;&gt; tags\n</code></pre>"},{"location":"refs/imports/","title":"Imports","text":""},{"location":"refs/imports/#feu.imports","title":"feu.imports","text":"<p>Contain to check if a package or module is available.</p>"},{"location":"refs/imports/#feu.imports.check_click","title":"feu.imports.check_click","text":"<pre><code>check_click() -&gt; None\n</code></pre> <p>Check if the <code>click</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>click</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import check_click\n&gt;&gt;&gt; check_click()\n</code></pre>"},{"location":"refs/imports/#feu.imports.check_git","title":"feu.imports.check_git","text":"<pre><code>check_git() -&gt; None\n</code></pre> <p>Check if the <code>git</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>git</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import check_git\n&gt;&gt;&gt; check_git()\n</code></pre>"},{"location":"refs/imports/#feu.imports.check_requests","title":"feu.imports.check_requests","text":"<pre><code>check_requests() -&gt; None\n</code></pre> <p>Check if the <code>requests</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>requests</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import check_requests\n&gt;&gt;&gt; check_requests()\n</code></pre>"},{"location":"refs/imports/#feu.imports.check_urllib3","title":"feu.imports.check_urllib3","text":"<pre><code>check_urllib3() -&gt; None\n</code></pre> <p>Check if the <code>urllib3</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>urllib3</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import check_urllib3\n&gt;&gt;&gt; check_urllib3()\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_click_available","title":"feu.imports.is_click_available  <code>cached</code>","text":"<pre><code>is_click_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>click</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>click</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import is_click_available\n&gt;&gt;&gt; is_click_available()\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_git_available","title":"feu.imports.is_git_available  <code>cached</code>","text":"<pre><code>is_git_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>git</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>git</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import is_git_available\n&gt;&gt;&gt; is_git_available()\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_module_available","title":"feu.imports.is_module_available  <code>cached</code>","text":"<pre><code>is_module_available(module: str) -&gt; bool\n</code></pre> <p>Check if a module path is available.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>str</code> <p>The module to check.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu import is_module_available\n&gt;&gt;&gt; is_module_available(\"os\")\nTrue\n&gt;&gt;&gt; is_module_available(\"os.path\")\nTrue\n&gt;&gt;&gt; is_module_available(\"missing.module\")\nFalse\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_package_available","title":"feu.imports.is_package_available  <code>cached</code>","text":"<pre><code>is_package_available(package: str) -&gt; bool\n</code></pre> <p>Check if a package is available.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the package is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu import is_package_available\n&gt;&gt;&gt; is_package_available(\"os\")\nTrue\n&gt;&gt;&gt; is_package_available(\"os.path\")\nTrue\n&gt;&gt;&gt; is_package_available(\"my_missing_package\")\nFalse\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_requests_available","title":"feu.imports.is_requests_available  <code>cached</code>","text":"<pre><code>is_requests_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>requests</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>requests</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import is_requests_available\n&gt;&gt;&gt; is_requests_available()\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_urllib3_available","title":"feu.imports.is_urllib3_available  <code>cached</code>","text":"<pre><code>is_urllib3_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>urllib3</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>urllib3</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import is_urllib3_available\n&gt;&gt;&gt; is_urllib3_available()\n</code></pre>"},{"location":"refs/install/","title":"Install","text":""},{"location":"refs/install/#feu.install","title":"feu.install","text":"<p>Contain package installers.</p>"},{"location":"refs/install/#feu.install.BaseInstaller","title":"feu.install.BaseInstaller","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipInstaller()\n&gt;&gt;&gt; installer\nPipInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.BaseInstaller.equal","title":"feu.install.BaseInstaller.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two installers are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two installers are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; obj1 = PipInstaller()\n&gt;&gt;&gt; obj2 = PipInstaller()\n&gt;&gt;&gt; obj3 = PipInstaller(\"-U\")\n&gt;&gt;&gt; obj1.equal(obj2)\nTrue\n&gt;&gt;&gt; obj1.equal(obj3)\nFalse\n</code></pre>"},{"location":"refs/install/#feu.install.BaseInstaller.install","title":"feu.install.BaseInstaller.install  <code>abstractmethod</code>","text":"<pre><code>install(package: PackageSpec) -&gt; None\n</code></pre> <p>Install the given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>PackageSpec</code> <p>The package specification of the package to install.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipInstaller()\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.BaseInstaller.instantiate_with_arguments","title":"feu.install.BaseInstaller.instantiate_with_arguments  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>instantiate_with_arguments(arguments: str) -&gt; Self\n</code></pre> <p>Instantiate an installer instance with custom arguments.</p> <p>Parameters:</p> Name Type Description Default <code>arguments</code> <code>str</code> <p>The installer arguments.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An instantiated installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; installer = PipInstaller.instantiate_with_arguments(\"-U\")\n&gt;&gt;&gt; installer\nPipInstaller(arguments='-U')\n</code></pre>"},{"location":"refs/install/#feu.install.InstallerRegistry","title":"feu.install.InstallerRegistry","text":"<p>Implement the main installer registry.</p>"},{"location":"refs/install/#feu.install.InstallerRegistry.add_installer","title":"feu.install.InstallerRegistry.add_installer  <code>classmethod</code>","text":"<pre><code>add_installer(\n    name: str,\n    installer: type[BaseInstaller],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an installer for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The installer name e.g. pip or uv.</p> required <code>installer</code> <code>type[BaseInstaller]</code> <p>The installer used for the given package.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the installer already exists. This parameter should be set to <code>True</code> to overwrite the installer for a package.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an installer is already registered for the package name and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import InstallerRegistry\n&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; InstallerRegistry.add_installer(\"pip\", PipInstaller, exist_ok=True)\n</code></pre>"},{"location":"refs/install/#feu.install.InstallerRegistry.has_installer","title":"feu.install.InstallerRegistry.has_installer  <code>classmethod</code>","text":"<pre><code>has_installer(name: str) -&gt; bool\n</code></pre> <p>Indicate if an installer is registered for the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The installer name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an installer is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import InstallerRegistry\n&gt;&gt;&gt; InstallerRegistry.has_installer(\"pip\")\nTrue\n</code></pre>"},{"location":"refs/install/#feu.install.InstallerRegistry.install","title":"feu.install.InstallerRegistry.install  <code>classmethod</code>","text":"<pre><code>install(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package and associated packages by using the specified installer.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import InstallerRegistry\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; InstallerRegistry.install(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.get_available_installers","title":"feu.install.get_available_installers  <code>cached</code>","text":"<pre><code>get_available_installers() -&gt; tuple[str, ...]\n</code></pre> <p>Get the available installers.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The available installers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import get_available_installers\n&gt;&gt;&gt; get_available_installers()\n(...)\n</code></pre>"},{"location":"refs/install/#feu.install.install_package","title":"feu.install.install_package","text":"<pre><code>install_package(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package with the specified installer.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.install_package_closest_version","title":"feu.install.install_package_closest_version","text":"<pre><code>install_package_closest_version(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package and associated packages by using the secified installer.</p> <p>This function finds the closest valid version if the specified version is not compatible.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package_closest_version\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package_closest_version(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.is_pip_available","title":"feu.install.is_pip_available  <code>cached</code>","text":"<pre><code>is_pip_available() -&gt; bool\n</code></pre> <p>Check if <code>pip</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pip</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_pip_available\n&gt;&gt;&gt; is_pip_available()\n</code></pre>"},{"location":"refs/install/#feu.install.is_pipx_available","title":"feu.install.is_pipx_available  <code>cached</code>","text":"<pre><code>is_pipx_available() -&gt; bool\n</code></pre> <p>Check if <code>pipx</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pipx</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_pipx_available\n&gt;&gt;&gt; is_pipx_available()\n</code></pre>"},{"location":"refs/install/#feu.install.is_uv_available","title":"feu.install.is_uv_available  <code>cached</code>","text":"<pre><code>is_uv_available() -&gt; bool\n</code></pre> <p>Check if <code>uv</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>uv</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_uv_available\n&gt;&gt;&gt; is_uv_available()\n</code></pre>"},{"location":"refs/install/#feu.install.pip","title":"feu.install.pip","text":"<p>Contain functionalities to install packages with pip or compatible package installers.</p>"},{"location":"refs/install/#feu.install.pip.PipInstaller","title":"feu.install.pip.PipInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a pip package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipInstaller()\n&gt;&gt;&gt; installer\nPipInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.PipxInstaller","title":"feu.install.pip.PipxInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a pipx package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipxInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipxInstaller()\n&gt;&gt;&gt; installer\nPipxInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.UvInstaller","title":"feu.install.pip.UvInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a uv package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import UvInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = UvInstaller()\n&gt;&gt;&gt; installer\nUvInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.installer","title":"feu.install.pip.installer","text":"<p>Define the pip compatible installers.</p>"},{"location":"refs/install/#feu.install.pip.installer.BasePipInstaller","title":"feu.install.pip.installer.BasePipInstaller","text":"<p>               Bases: <code>BaseInstaller</code></p> <p>Define an intermediate base class to implement pip compatible package installer.</p> <p>Parameters:</p> Name Type Description Default <code>arguments</code> <code>str</code> <p>Optional arguments to pass to the package installer. The valid arguments depend on the package installer.</p> <code>''</code> <p>Example usage (subclassing):</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.installer import BasePipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec, PackageDependency\n&gt;&gt;&gt; class MyInstaller(BasePipInstaller):\n...     def _generate_command(self, deps, args):\n...         return f\"echo Installing {', '.join(map(str, deps))} with args: {args}\"\n...\n&gt;&gt;&gt; installer = MyInstaller(arguments=\"--verbose\")\n&gt;&gt;&gt; installer\nMyInstaller(arguments='--verbose')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.installer.PipInstaller","title":"feu.install.pip.installer.PipInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a pip package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipInstaller()\n&gt;&gt;&gt; installer\nPipInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.installer.PipxInstaller","title":"feu.install.pip.installer.PipxInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a pipx package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipxInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipxInstaller()\n&gt;&gt;&gt; installer\nPipxInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.installer.UvInstaller","title":"feu.install.pip.installer.UvInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a uv package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import UvInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = UvInstaller()\n&gt;&gt;&gt; installer\nUvInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver","title":"feu.install.pip.resolver","text":"<p>Contain pip compatible package dependency resolvers.</p>"},{"location":"refs/install/#feu.install.pip.resolver.BaseDependencyResolver","title":"feu.install.pip.resolver.BaseDependencyResolver","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class for pip-compatible package dependency resolvers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = DependencyResolver()\n&gt;&gt;&gt; resolver\nDependencyResolver()\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"my_package\", version=\"1.2.3\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.BaseDependencyResolver.equal","title":"feu.install.pip.resolver.BaseDependencyResolver.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two dependency resolvers are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two dependency resolvers are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolver, TorchDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; obj1 = DependencyResolver()\n&gt;&gt;&gt; obj2 = DependencyResolver()\n&gt;&gt;&gt; obj3 = TorchDependencyResolver()\n&gt;&gt;&gt; obj1.equal(obj2)\nTrue\n&gt;&gt;&gt; obj1.equal(obj3)\nFalse\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.BaseDependencyResolver.resolve","title":"feu.install.pip.resolver.BaseDependencyResolver.resolve  <code>abstractmethod</code>","text":"<pre><code>resolve(package: PackageSpec) -&gt; list[PackageDependency]\n</code></pre> <p>Find the dependency packages to install a specific package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>PackageSpec</code> <p>The target package to install.</p> required <p>Returns:</p> Type Description <code>list[PackageDependency]</code> <p>The list of package dependencies.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = DependencyResolver()\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"my_package\", version=\"1.2.3\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.DependencyResolver","title":"feu.install.pip.resolver.DependencyResolver","text":"<p>               Bases: <code>BaseDependencyResolver</code></p> <p>Define the default package dependency resolver.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = DependencyResolver()\n&gt;&gt;&gt; resolver\nDependencyResolver()\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"my_package\", version=\"1.2.3\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.DependencyResolverRegistry","title":"feu.install.pip.resolver.DependencyResolverRegistry","text":"<p>Implement the main dependency resolver registry.</p> <p>The dependency resolvers are indexed by name.</p>"},{"location":"refs/install/#feu.install.pip.resolver.DependencyResolverRegistry.add_resolver","title":"feu.install.pip.resolver.DependencyResolverRegistry.add_resolver  <code>classmethod</code>","text":"<pre><code>add_resolver(\n    package: PackageSpec,\n    resolver: BaseDependencyResolver,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a dependency resolver for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <code>resolver</code> <code>BaseDependencyResolver</code> <p>The resolver used for the given package.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the package already exists. This parameter should be set to <code>True</code> to overwrite the resolver for a package.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a dependency resolver is already registered for the package name and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import (\n...     DependencyResolverRegistry,\n...     TorchDependencyResolver,\n... )\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; DependencyResolverRegistry.add_resolver(\n...     PackageSpec(\"torch\"), TorchDependencyResolver(), exist_ok=True\n... )\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.DependencyResolverRegistry.find_resolver","title":"feu.install.pip.resolver.DependencyResolverRegistry.find_resolver  <code>classmethod</code>","text":"<pre><code>find_resolver(\n    package: PackageSpec,\n) -&gt; BaseDependencyResolver\n</code></pre> <p>Find the relevant dependency resolver for the given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Returns:</p> Type Description <code>BaseDependencyResolver</code> <p>The dependency resolver for the package.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolverRegistry\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = DependencyResolverRegistry.find_resolver(PackageSpec(\"torch\"))\n&gt;&gt;&gt; resolver\nTorchDependencyResolver(min_version=2.3.0)\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.DependencyResolverRegistry.has_resolver","title":"feu.install.pip.resolver.DependencyResolverRegistry.has_resolver  <code>classmethod</code>","text":"<pre><code>has_resolver(package: PackageSpec) -&gt; bool\n</code></pre> <p>Indicate if a dependency resolver is registered for the given package specification.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a dependency resolver is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolverRegistry\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; DependencyResolverRegistry.has_resolver(PackageSpec(\"torch\"))\nTrue\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.JaxDependencyResolver","title":"feu.install.pip.resolver.JaxDependencyResolver","text":"<p>               Bases: <code>DependencyResolver</code></p> <p>Implement the <code>jax</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>jax</code> 0.4.26.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import JaxDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = JaxDependencyResolver()\n&gt;&gt;&gt; resolver\nJaxDependencyResolver()\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"jax\", version=\"0.4.26\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='jax', version_specifiers=['==0.4.26'], extras=None),\n PackageDependency(name='jaxlib', version_specifiers=['==0.4.26'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"jax\", version=\"0.4.25\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='jax', version_specifiers=['==0.4.25'], extras=None),\n PackageDependency(name='jaxlib', version_specifiers=['==0.4.25'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.MatplotlibDependencyResolver","title":"feu.install.pip.resolver.MatplotlibDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>matplotlib</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>matplotlib</code> 3.8.4.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import MatplotlibDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = MatplotlibDependencyResolver()\n&gt;&gt;&gt; resolver\nMatplotlibDependencyResolver(min_version=3.8.4)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"matplotlib\", version=\"3.8.4\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='matplotlib', version_specifiers=['==3.8.4'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"matplotlib\", version=\"3.8.3\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='matplotlib', version_specifiers=['==3.8.3'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.Numpy2DependencyResolver","title":"feu.install.pip.resolver.Numpy2DependencyResolver","text":"<p>               Bases: <code>DependencyResolver</code></p> <p>Define a dependency resolver to work with packages that did not pin <code>numpy&lt;2.0</code> and are not fully compatible with numpy 2.0.</p> <p>https://github.com/numpy/numpy/issues/26191 indicates the packages that are compatible with numpy 2.0.</p> <p>Parameters:</p> Name Type Description Default <code>min_version</code> <code>str</code> <p>The first version that is fully compatible with numpy 2.0.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import Numpy2DependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = Numpy2DependencyResolver(min_version=\"1.2.3\")\n&gt;&gt;&gt; resolver\nNumpy2DependencyResolver(min_version=1.2.3)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"my_package\", version=\"1.2.3\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"my_package\", version=\"1.2.2\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='my_package', version_specifiers=['==1.2.2'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.PandasDependencyResolver","title":"feu.install.pip.resolver.PandasDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>pandas</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>pandas</code> 2.2.2.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import PandasDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = PandasDependencyResolver()\n&gt;&gt;&gt; resolver\nPandasDependencyResolver(min_version=2.2.2)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"pandas\", version=\"2.2.2\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='pandas', version_specifiers=['==2.2.2'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"pandas\", version=\"2.2.1\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='pandas', version_specifiers=['==2.2.1'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.PyarrowDependencyResolver","title":"feu.install.pip.resolver.PyarrowDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>pyarrow</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>pyarrow</code> 16.0.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import PyarrowDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = PyarrowDependencyResolver()\n&gt;&gt;&gt; resolver\nPyarrowDependencyResolver(min_version=16.0)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"pyarrow\", version=\"16.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='pyarrow', version_specifiers=['==16.0'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"pyarrow\", version=\"15.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='pyarrow', version_specifiers=['==15.0'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.ScipyDependencyResolver","title":"feu.install.pip.resolver.ScipyDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>scipy</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>scipy</code> 1.13.0.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import ScipyDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = ScipyDependencyResolver()\n&gt;&gt;&gt; resolver\nScipyDependencyResolver(min_version=1.13.0)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"scipy\", version=\"1.13.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='scipy', version_specifiers=['==1.13.0'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"scipy\", version=\"1.12.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='scipy', version_specifiers=['==1.12.0'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.SklearnDependencyResolver","title":"feu.install.pip.resolver.SklearnDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>scikit-learn</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>scikit-learn</code> 1.4.2.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import SklearnDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = SklearnDependencyResolver()\n&gt;&gt;&gt; resolver\nSklearnDependencyResolver(min_version=1.4.2)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"scikit-learn\", version=\"1.4.2\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='scikit-learn', version_specifiers=['==1.4.2'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"scikit-learn\", version=\"1.4.1\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='scikit-learn', version_specifiers=['==1.4.1'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.TorchDependencyResolver","title":"feu.install.pip.resolver.TorchDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>torch</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>torch</code> 2.3.0.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import TorchDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = TorchDependencyResolver()\n&gt;&gt;&gt; resolver\nTorchDependencyResolver(min_version=2.3.0)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"torch\", version=\"2.3.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='torch', version_specifiers=['==2.3.0'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"torch\", version=\"2.2.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='torch', version_specifiers=['==2.2.0'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.XarrayDependencyResolver","title":"feu.install.pip.resolver.XarrayDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>xarray</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>xarray</code> 2024.6.0.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import XarrayDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = XarrayDependencyResolver()\n&gt;&gt;&gt; resolver\nXarrayDependencyResolver(min_version=2024.6.0)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"xarray\", version=\"2024.6.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='xarray', version_specifiers=['==2024.6.0'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"xarray\", version=\"2024.5.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='xarray', version_specifiers=['==2024.5.0'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.utils","title":"feu.install.utils","text":"<p>Contain utility functions to install packages.</p>"},{"location":"refs/install/#feu.install.utils.get_available_installers","title":"feu.install.utils.get_available_installers  <code>cached</code>","text":"<pre><code>get_available_installers() -&gt; tuple[str, ...]\n</code></pre> <p>Get the available installers.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The available installers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import get_available_installers\n&gt;&gt;&gt; get_available_installers()\n(...)\n</code></pre>"},{"location":"refs/install/#feu.install.utils.install_package","title":"feu.install.utils.install_package","text":"<pre><code>install_package(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package with the specified installer.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.utils.install_package_closest_version","title":"feu.install.utils.install_package_closest_version","text":"<pre><code>install_package_closest_version(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package and associated packages by using the secified installer.</p> <p>This function finds the closest valid version if the specified version is not compatible.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package_closest_version\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package_closest_version(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.utils.is_pip_available","title":"feu.install.utils.is_pip_available  <code>cached</code>","text":"<pre><code>is_pip_available() -&gt; bool\n</code></pre> <p>Check if <code>pip</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pip</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_pip_available\n&gt;&gt;&gt; is_pip_available()\n</code></pre>"},{"location":"refs/install/#feu.install.utils.is_pipx_available","title":"feu.install.utils.is_pipx_available  <code>cached</code>","text":"<pre><code>is_pipx_available() -&gt; bool\n</code></pre> <p>Check if <code>pipx</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pipx</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_pipx_available\n&gt;&gt;&gt; is_pipx_available()\n</code></pre>"},{"location":"refs/install/#feu.install.utils.is_uv_available","title":"feu.install.utils.is_uv_available  <code>cached</code>","text":"<pre><code>is_uv_available() -&gt; bool\n</code></pre> <p>Check if <code>uv</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>uv</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_uv_available\n&gt;&gt;&gt; is_uv_available()\n</code></pre>"},{"location":"refs/package/","title":"Package","text":""},{"location":"refs/package/#feu.package","title":"feu.package","text":"<p>Contain functions to check a package configuration.</p>"},{"location":"refs/package/#feu.package.PackageConfig","title":"feu.package.PackageConfig","text":"<p>Implement the main package config registry.</p>"},{"location":"refs/package/#feu.package.PackageConfig.add_config","title":"feu.package.PackageConfig.add_config  <code>classmethod</code>","text":"<pre><code>add_config(\n    pkg_name: str,\n    pkg_version_min: str | None,\n    pkg_version_max: str | None,\n    python_version: str,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a new package configuration.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>pkg_version_min</code> <code>str | None</code> <p>The minimum valid package version for this configuration. <code>None</code> means there is no minimum valid package version.</p> required <code>pkg_version_max</code> <code>str | None</code> <p>The maximum valid package version for this configuration. <code>None</code> means there is no maximum valid package version.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if a package configuration already exists. This parameter should be  set to <code>True</code> to overwrite the package configuration.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a package configuration is already registered and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import PackageConfig\n&gt;&gt;&gt; PackageConfig.add_config(\n...     pkg_name=\"my_package\",\n...     python_version=\"3.11\",\n...     pkg_version_min=\"1.2.0\",\n...     pkg_version_max=\"2.0.2\",\n...     exist_ok=True,\n... )\n</code></pre>"},{"location":"refs/package/#feu.package.PackageConfig.find_closest_version","title":"feu.package.PackageConfig.find_closest_version  <code>classmethod</code>","text":"<pre><code>find_closest_version(\n    pkg_name: str, pkg_version: str, python_version: str\n) -&gt; str\n</code></pre> <p>Find the closest valid version given the package name and version, and python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>pkg_version</code> <code>str</code> <p>The package version to check.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The closest valid version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import PackageConfig\n&gt;&gt;&gt; PackageConfig.find_closest_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"2.0.2\",\n...     python_version=\"3.11\",\n... )\n2.0.2\n&gt;&gt;&gt; PackageConfig.find_closest_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"1.0.2\",\n...     python_version=\"3.11\",\n... )\n1.23.2\n</code></pre>"},{"location":"refs/package/#feu.package.PackageConfig.get_config","title":"feu.package.PackageConfig.get_config  <code>classmethod</code>","text":"<pre><code>get_config(\n    pkg_name: str, python_version: str\n) -&gt; dict[str, str]\n</code></pre> <p>Get a package configuration given the package name and python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>The package configuration.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import PackageConfig\n&gt;&gt;&gt; PackageConfig.get_config(\n...     pkg_name=\"numpy\",\n...     python_version=\"3.11\",\n... )\n{'min': '1.23.2', 'max': None}\n</code></pre>"},{"location":"refs/package/#feu.package.PackageConfig.get_min_and_max_versions","title":"feu.package.PackageConfig.get_min_and_max_versions  <code>classmethod</code>","text":"<pre><code>get_min_and_max_versions(\n    pkg_name: str, python_version: str\n) -&gt; tuple[Version | None, Version | None]\n</code></pre> <p>Get the minimum and maximum versions for the given package name and python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>tuple[Version | None, Version | None]</code> <p>A tuple with the minimum and maximum versions. The version is set to <code>None</code> if there is no minimum or maximum version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import PackageConfig\n&gt;&gt;&gt; PackageConfig.get_min_and_max_versions(\n...     pkg_name=\"numpy\",\n...     python_version=\"3.11\",\n... )\n(&lt;Version('1.23.2')&gt;, None)\n</code></pre>"},{"location":"refs/package/#feu.package.PackageConfig.is_valid_version","title":"feu.package.PackageConfig.is_valid_version  <code>classmethod</code>","text":"<pre><code>is_valid_version(\n    pkg_name: str, pkg_version: str, python_version: str\n) -&gt; bool\n</code></pre> <p>Indicate if the specified package version is valid for the given Python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>pkg_version</code> <code>str</code> <p>The package version to check.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the specified package version is valid for the given Python version, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import PackageConfig\n&gt;&gt;&gt; PackageConfig.is_valid_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"2.0.2\",\n...     python_version=\"3.11\",\n... )\nTrue\n&gt;&gt;&gt; PackageConfig.is_valid_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"1.0.2\",\n...     python_version=\"3.11\",\n... )\nFalse\n</code></pre>"},{"location":"refs/package/#feu.package.find_closest_version","title":"feu.package.find_closest_version","text":"<pre><code>find_closest_version(\n    pkg_name: str, pkg_version: str, python_version: str\n) -&gt; str\n</code></pre> <p>Find the closest valid version given the package name and version, and python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>pkg_version</code> <code>str</code> <p>The package version to check.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The closest valid version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import find_closest_version\n&gt;&gt;&gt; find_closest_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"2.0.2\",\n...     python_version=\"3.11\",\n... )\n2.0.2\n&gt;&gt;&gt; find_closest_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"1.0.2\",\n...     python_version=\"3.11\",\n... )\n1.23.2\n</code></pre>"},{"location":"refs/package/#feu.package.is_valid_version","title":"feu.package.is_valid_version","text":"<pre><code>is_valid_version(\n    pkg_name: str, pkg_version: str, python_version: str\n) -&gt; bool\n</code></pre> <p>Indicate if the specified package version is valid for the given Python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>pkg_version</code> <code>str</code> <p>The package version to check.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the specified package version is valid for the given Python version, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import is_valid_version\n&gt;&gt;&gt; is_valid_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"2.0.2\",\n...     python_version=\"3.11\",\n... )\nTrue\n&gt;&gt;&gt; is_valid_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"1.0.2\",\n...     python_version=\"3.11\",\n... )\nFalse\n</code></pre>"},{"location":"refs/repo/","title":"Repo","text":""},{"location":"refs/repo/#feu.repo","title":"feu.repo","text":"<p>Contain functions to manage repos.</p>"},{"location":"refs/repo/#feu.repo.fetch_github_metadata","title":"feu.repo.fetch_github_metadata  <code>cached</code>","text":"<pre><code>fetch_github_metadata(owner: str, repo: str) -&gt; dict\n</code></pre> <p>Get the GitHub repo metadata.</p> <p>The metadata is read from GitHub API.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The repo name.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The repo metadata.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.repo import fetch_github_metadata\n&gt;&gt;&gt; metadata = fetch_github_metadata(owner=\"durandtibo\", repo=\"feu\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/root/","title":"Main functions","text":""},{"location":"refs/root/#feu","title":"feu","text":"<p>Root package of <code>feu</code>.</p>"},{"location":"refs/root/#feu.compare_version","title":"feu.compare_version","text":"<pre><code>compare_version(\n    package: str, op: Callable, version: str\n) -&gt; bool\n</code></pre> <p>Compare a package version to a given version.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package to check.</p> required <code>op</code> <code>Callable</code> <p>The comparison operator.</p> required <code>version</code> <code>str</code> <p>The version to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The comparison status.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; from feu.version import compare_version\n&gt;&gt;&gt; compare_version(\"pytest\", op=operator.ge, version=\"7.3.0\")\nTrue\n</code></pre>"},{"location":"refs/root/#feu.get_package_version","title":"feu.get_package_version","text":"<pre><code>get_package_version(package: str) -&gt; Version | None\n</code></pre> <p>Get the package version.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <p>Returns:</p> Type Description <code>Version | None</code> <p>The package version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import get_package_version\n&gt;&gt;&gt; get_package_version(\"pytest\")\n&lt;Version('...')&gt;\n</code></pre>"},{"location":"refs/root/#feu.install_package","title":"feu.install_package","text":"<pre><code>install_package(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package with the specified installer.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/root/#feu.install_package_closest_version","title":"feu.install_package_closest_version","text":"<pre><code>install_package_closest_version(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package and associated packages by using the secified installer.</p> <p>This function finds the closest valid version if the specified version is not compatible.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package_closest_version\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package_closest_version(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/root/#feu.is_module_available","title":"feu.is_module_available  <code>cached</code>","text":"<pre><code>is_module_available(module: str) -&gt; bool\n</code></pre> <p>Check if a module path is available.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>str</code> <p>The module to check.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu import is_module_available\n&gt;&gt;&gt; is_module_available(\"os\")\nTrue\n&gt;&gt;&gt; is_module_available(\"os.path\")\nTrue\n&gt;&gt;&gt; is_module_available(\"missing.module\")\nFalse\n</code></pre>"},{"location":"refs/root/#feu.is_package_available","title":"feu.is_package_available  <code>cached</code>","text":"<pre><code>is_package_available(package: str) -&gt; bool\n</code></pre> <p>Check if a package is available.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the package is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu import is_package_available\n&gt;&gt;&gt; is_package_available(\"os\")\nTrue\n&gt;&gt;&gt; is_package_available(\"os.path\")\nTrue\n&gt;&gt;&gt; is_package_available(\"my_missing_package\")\nFalse\n</code></pre>"},{"location":"refs/testing/","title":"Testing","text":""},{"location":"refs/testing/#feu.testing","title":"feu.testing","text":"<p>Define some utility functions for testing.</p>"},{"location":"refs/utils/","title":"Utils","text":""},{"location":"refs/utils/#feu.utils","title":"feu.utils","text":"<p>Contain the utility functions.</p>"},{"location":"refs/utils/#feu.utils.command","title":"feu.utils.command","text":"<p>Contain utility functions to run commands.</p>"},{"location":"refs/utils/#feu.utils.command.run_bash_command","title":"feu.utils.command.run_bash_command","text":"<pre><code>run_bash_command(cmd: str) -&gt; None\n</code></pre> <p>Execute a bash command.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The command to run.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.command import run_bash_command\n&gt;&gt;&gt; run_bash_command(\"ls -l\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/utils/#feu.utils.installer","title":"feu.utils.installer","text":"<p>Contain utility functions to manage installers.</p>"},{"location":"refs/utils/#feu.utils.installer.InstallerSpec","title":"feu.utils.installer.InstallerSpec  <code>dataclass</code>","text":"<p>Define a dataclass to represent an installer specification.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The installer name.</p> required <code>arguments</code> <code>str</code> <p>A string containing optional installer arguments.</p> <code>''</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; installer1 = InstallerSpec(\"pip\")\n&gt;&gt;&gt; installer1\nInstallerSpec(name='pip', arguments='')\n&gt;&gt;&gt; installer2 = InstallerSpec(\"pip\", arguments=\"-U\")\n&gt;&gt;&gt; installer2\nInstallerSpec(name='pip', arguments='-U')\n</code></pre>"},{"location":"refs/utils/#feu.utils.package","title":"feu.utils.package","text":"<p>Contain utility functions to manage packages.</p>"},{"location":"refs/utils/#feu.utils.package.PackageDependency","title":"feu.utils.package.PackageDependency  <code>dataclass</code>","text":"<p>Define a dataclass to represent a package dependency.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The package name.</p> required <code>version_specifiers</code> <code>list[str] | None</code> <p>Optional package version specifies.</p> <code>None</code> <code>extras</code> <code>list[str] | None</code> <p>Optional package extra dependencies.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import PackageDependency\n&gt;&gt;&gt; pkg1 = PackageDependency(\"my_package\")\n&gt;&gt;&gt; pkg1\nPackageDependency(name='my_package', version_specifiers=None, extras=None)\n&gt;&gt;&gt; pkg2 = PackageDependency(\"my_package\", version_specifiers=[\"==1.2.3\"])\n&gt;&gt;&gt; pkg2\nPackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=None)\n&gt;&gt;&gt; pkg3 = PackageDependency(\n...     \"my_package\", version_specifiers=[\"==1.2.3\"], extras=[\"security\", \"socks\"]\n... )\n&gt;&gt;&gt; pkg3\nPackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=['security', 'socks'])\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.PackageSpec","title":"feu.utils.package.PackageSpec  <code>dataclass</code>","text":"<p>Define a dataclass to represent a package specification.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The package name.</p> required <code>version</code> <code>str | None</code> <p>An optional package version.</p> <code>None</code> <code>extras</code> <code>list[str] | None</code> <p>Optional package extra dependencies.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; pkg1 = PackageSpec(\"my_package\")\n&gt;&gt;&gt; pkg1\nPackageSpec(name='my_package', version=None, extras=None)\n&gt;&gt;&gt; pkg2 = PackageSpec(\"my_package\", version=\"1.2.3\")\n&gt;&gt;&gt; pkg2\nPackageSpec(name='my_package', version='1.2.3', extras=None)\n&gt;&gt;&gt; pkg3 = PackageSpec(\"my_package\", version=\"1.2.3\", extras=[\"security\", \"socks\"])\n&gt;&gt;&gt; pkg3\nPackageSpec(name='my_package', version='1.2.3', extras=['security', 'socks'])\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.PackageSpec.to_package_dependency","title":"feu.utils.package.PackageSpec.to_package_dependency","text":"<pre><code>to_package_dependency() -&gt; PackageDependency\n</code></pre> <p>Convert to a <code>PackageDependency</code>.</p> <p>Returns:</p> Type Description <code>PackageDependency</code> <p>The current package as a package dependency.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; pkg = PackageSpec(\"my_package\")\n&gt;&gt;&gt; dep = pkg.to_package_dependency()\n&gt;&gt;&gt; dep\nPackageDependency(name='my_package', version_specifiers=None, extras=None)\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.PackageSpec.with_version","title":"feu.utils.package.PackageSpec.with_version","text":"<pre><code>with_version(version: str | None) -&gt; PackageSpec\n</code></pre> <p>Create a new <code>PackageSpec</code> instance with the given version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str | None</code> <p>The new version to apply.</p> required <p>Returns:</p> Type Description <code>PackageSpec</code> <p>A new instance of PackageSpec with the updated version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; pkg = PackageSpec(\"my_package\", version=\"1.2.0\")\n&gt;&gt;&gt; pkg\nPackageSpec(name='my_package', version='1.2.0', extras=None)\n&gt;&gt;&gt; pkg2 = pkg.with_version(\"1.2.3\")\n&gt;&gt;&gt; pkg2\nPackageSpec(name='my_package', version='1.2.3', extras=None)\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.extract_package_extras","title":"feu.utils.package.extract_package_extras","text":"<pre><code>extract_package_extras(requirement: str) -&gt; list[str]\n</code></pre> <p>Extract the optional extras from a requirement string.</p> <p>The requirement string may include extras in square brackets, e.g., 'package[extra1,extra2]'. This function returns the list of extras.</p> <p>Parameters:</p> Name Type Description Default <code>requirement</code> <code>str</code> <p>The requirement string containing the package name and optionally extra dependencies.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of extra requirements, or an empty list if none exist.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import extract_package_extras\n&gt;&gt;&gt; extract_package_extras(\"numpy\")\n[]\n&gt;&gt;&gt; extract_package_extras(\"pandas[performance]\")\n['performance']\n&gt;&gt;&gt; extract_package_extras(\"requests[security,socks]\")\n['security', 'socks']\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.extract_package_name","title":"feu.utils.package.extract_package_name","text":"<pre><code>extract_package_name(requirement: str) -&gt; str\n</code></pre> <p>Extract the base package name from a requirement string.</p> <p>The requirement string may include optional dependencies in square brackets, such as 'package[extra1,extra2]'. This function returns only the base package name without the extras.</p> <p>Parameters:</p> Name Type Description Default <code>requirement</code> <code>str</code> <p>The requirement string containing the package name and optionally extra dependencies.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The base package name without extras.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import extract_package_name\n&gt;&gt;&gt; extract_package_name(\"numpy\")\n'numpy'\n&gt;&gt;&gt; extract_package_name(\"pandas[performance]\")\n'pandas'\n&gt;&gt;&gt; extract_package_name(\"requests[security,socks]\")\n'requests'\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.generate_extras_string","title":"feu.utils.package.generate_extras_string","text":"<pre><code>generate_extras_string(extras: Sequence[str]) -&gt; str\n</code></pre> <p>Generate a string with the package extras i.e. optional dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>Sequence[str]</code> <p>The package optional dependencies.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string with the package extras.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import generate_extras_string\n&gt;&gt;&gt; generate_extras_string([\"security\"])\n'[security]'\n&gt;&gt;&gt; generate_extras_string([\"security\", \"socks\"])\n'[security,socks]'\n&gt;&gt;&gt; generate_extras_string([])\n''\n</code></pre>"},{"location":"refs/version/","title":"Version","text":""},{"location":"refs/version/#feu.version","title":"feu.version","text":"<p>Contain functions to manage package versions.</p>"},{"location":"refs/version/#feu.version.compare_version","title":"feu.version.compare_version","text":"<pre><code>compare_version(\n    package: str, op: Callable, version: str\n) -&gt; bool\n</code></pre> <p>Compare a package version to a given version.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package to check.</p> required <code>op</code> <code>Callable</code> <p>The comparison operator.</p> required <code>version</code> <code>str</code> <p>The version to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The comparison status.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; from feu.version import compare_version\n&gt;&gt;&gt; compare_version(\"pytest\", op=operator.ge, version=\"7.3.0\")\nTrue\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_latest_major_versions","title":"feu.version.fetch_latest_major_versions","text":"<pre><code>fetch_latest_major_versions(\n    package: str,\n    lower: str | None = None,\n    upper: str | None = None,\n) -&gt; tuple[str, ...]\n</code></pre> <p>Get the latest version for each major version for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <code>lower</code> <code>str | None</code> <p>The lower version bound (inclusive). If <code>None</code>, no lower limit is applied.</p> <code>None</code> <code>upper</code> <code>str | None</code> <p>The upper version bound (exclusive). If None, no upper limit is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple containing the latest version for each major version, sorted by major version number.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_latest_major_versions\n&gt;&gt;&gt; versions = fetch_latest_major_versions(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_latest_minor_versions","title":"feu.version.fetch_latest_minor_versions","text":"<pre><code>fetch_latest_minor_versions(\n    package: str,\n    lower: str | None = None,\n    upper: str | None = None,\n) -&gt; tuple[str, ...]\n</code></pre> <p>Get the latest version for each minor version for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <code>lower</code> <code>str | None</code> <p>The lower version bound (inclusive). If <code>None</code>, no lower limit is applied.</p> <code>None</code> <code>upper</code> <code>str | None</code> <p>The upper version bound (exclusive). If None, no upper limit is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple containing the latest version for each minor version, sorted by minor version number.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_latest_minor_versions\n&gt;&gt;&gt; versions = fetch_latest_minor_versions(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_latest_stable_version","title":"feu.version.fetch_latest_stable_version","text":"<pre><code>fetch_latest_stable_version(package: str) -&gt; str\n</code></pre> <p>Get the latest stable valid versions for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The latest stable valid versions.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_latest_stable_version\n&gt;&gt;&gt; version = fetch_latest_stable_version(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_latest_version","title":"feu.version.fetch_latest_version","text":"<pre><code>fetch_latest_version(package: str) -&gt; str\n</code></pre> <p>Get the latest valid versions for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The latest valid versions.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_latest_version\n&gt;&gt;&gt; version = fetch_latest_version(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_pypi_versions","title":"feu.version.fetch_pypi_versions  <code>cached</code>","text":"<pre><code>fetch_pypi_versions(\n    package: str, reverse: bool = False\n) -&gt; tuple[str, ...]\n</code></pre> <p>Get the package versions available on PyPI.</p> <p>The package versions are read from PyPI.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <code>reverse</code> <code>bool</code> <p>If <code>False</code>, sort in ascending order; if <code>True</code>, sort in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A list containing the sorted version strings.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_pypi_versions\n&gt;&gt;&gt; versions = fetch_pypi_versions(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_versions","title":"feu.version.fetch_versions","text":"<pre><code>fetch_versions(\n    package: str,\n    lower: str | None = None,\n    upper: str | None = None,\n) -&gt; tuple[str, ...]\n</code></pre> <p>Get the valid versions for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <code>lower</code> <code>str | None</code> <p>The lower version bound (inclusive). If <code>None</code>, no lower limit is applied.</p> <code>None</code> <code>upper</code> <code>str | None</code> <p>The upper version bound (exclusive). If None, no upper limit is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple containing the valid versions.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_versions\n&gt;&gt;&gt; versions = fetch_versions(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.filter_every_n_versions","title":"feu.version.filter_every_n_versions","text":"<pre><code>filter_every_n_versions(\n    versions: Sequence[str], n: int\n) -&gt; list[str]\n</code></pre> <p>Filter a list of version strings, keeping only every n-th version using 0-based indexing.</p> <p>This function preserves the original order of the input list and returns a new list containing only the versions at positions that are multiples of <code>n</code> (using 0-based indexing). For example, if <code>n = 2</code>, the function keeps the 0th, 2nd, 4th, ... versions from the list.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <code>n</code> <code>int</code> <p>The interval for selecting versions. Must be &gt;= 1.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A new list containing only every n-th version in <code>versions</code>, starting from index 0.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>n</code> is less than 1.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import filter_every_n_versions\n&gt;&gt;&gt; versions = filter_every_n_versions([\"1.0\", \"1.1\", \"1.2\", \"1.3\", \"1.5\", \"1.6\"], n=2)\n&gt;&gt;&gt; versions\n['1.0', '1.2', '1.5']\n&gt;&gt;&gt; versions = filter_every_n_versions([\"1.0\", \"1.1\", \"1.2\", \"1.3\", \"1.5\", \"1.6\"], n=1)\n&gt;&gt;&gt; versions\n['1.0', '1.1', '1.2', '1.3', '1.5', '1.6']\n</code></pre>"},{"location":"refs/version/#feu.version.filter_last_n_versions","title":"feu.version.filter_last_n_versions","text":"<pre><code>filter_last_n_versions(\n    versions: Sequence[str], n: int\n) -&gt; list[str]\n</code></pre> <p>Return only the last n versions from a list of version strings.</p> <p>This function preserves the original ordering of the final n elements. If <code>n</code> is greater than the number of versions available, the entire list is returned. If <code>n</code> is zero, an empty list is returned.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <code>n</code> <code>int</code> <p>Number of versions to keep from the end of the list. Must be &gt;= 0.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A new list containing only the last n versions, in order.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>n</code> is less than 1.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import filter_last_n_versions\n&gt;&gt;&gt; versions = filter_last_n_versions([\"1.0\", \"1.1\", \"1.2\", \"1.3\"], n=2)\n&gt;&gt;&gt; versions\n['1.2', '1.3']\n&gt;&gt;&gt; versions = filter_last_n_versions([\"1.0\", \"1.1\", \"1.2\", \"1.3\"], n=5)\n&gt;&gt;&gt; versions\n['1.0', '1.1', '1.2', '1.3']\n</code></pre>"},{"location":"refs/version/#feu.version.filter_range_versions","title":"feu.version.filter_range_versions","text":"<pre><code>filter_range_versions(\n    versions: Sequence[str],\n    lower: str | None = None,\n    upper: str | None = None,\n) -&gt; list[str]\n</code></pre> <p>Filter a list of version strings to include only versions within optional bounds.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <code>lower</code> <code>str | None</code> <p>The lower version bound (inclusive). If <code>None</code>, no lower limit is applied.</p> <code>None</code> <code>upper</code> <code>str | None</code> <p>The upper version bound (exclusive). If None, no upper limit is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of version strings that fall within the specified bounds.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import filter_range_versions\n&gt;&gt;&gt; versions = filter_range_versions(\n...     [\"1.0.0\", \"1.2.0\", \"1.3.0\", \"2.0.0\"], lower=\"1.1.0\", upper=\"2.0.0\"\n... )\n&gt;&gt;&gt; versions\n['1.2.0', '1.3.0']\n&gt;&gt;&gt; versions = filter_range_versions([\"0.9.0\", \"1.0.0\", \"1.1.0\"], lower=\"1.0.0\")\n&gt;&gt;&gt; versions\n['1.0.0', '1.1.0']\n</code></pre>"},{"location":"refs/version/#feu.version.filter_stable_versions","title":"feu.version.filter_stable_versions","text":"<pre><code>filter_stable_versions(\n    versions: Sequence[str],\n) -&gt; list[str]\n</code></pre> <p>Filter out pre-release, post-release, and dev-release versions from a list of version strings.</p> A stable version is defined as <ul> <li>Not a pre-release (e.g., alpha <code>a</code>, beta <code>b</code>, release candidate <code>rc</code>)</li> <li>Not a post-release (e.g., <code>1.0.0.post1</code>)</li> <li>Not a development release (e.g., <code>1.0.0.dev1</code>)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list containing only stable version strings.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import filter_stable_versions\n&gt;&gt;&gt; versions = filter_stable_versions(\n...     [\"1.0.0\", \"1.0.0a1\", \"2.0.0\", \"2.0.0.dev1\", \"3.0.0.post1\"]\n... )\n&gt;&gt;&gt; versions\n['1.0.0', '2.0.0']\n</code></pre>"},{"location":"refs/version/#feu.version.filter_valid_versions","title":"feu.version.filter_valid_versions","text":"<pre><code>filter_valid_versions(versions: Sequence[str]) -&gt; list[str]\n</code></pre> <p>Filter out invalid version strings based on PEP 440.</p> <p>A valid version is one that can be parsed by <code>packaging.version.Version</code>. Invalid versions include strings that don't conform to semantic versioning rules.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list containing only valid version strings.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import filter_valid_versions\n&gt;&gt;&gt; versions = filter_valid_versions(\n...     [\n...         \"1.0.0\",\n...         \"1.0.0a1\",\n...         \"2.0.0.post1\",\n...         \"not-a-version\",\n...         \"\",\n...         \"2\",\n...         \"3.0\",\n...         \"v1.0.0\",\n...         \"1.0.0.0.0\",\n...         \"4.0.0.dev1\",\n...     ]\n... )\n&gt;&gt;&gt; versions\n['1.0.0', '1.0.0a1', '2.0.0.post1', '2', '3.0', 'v1.0.0', '1.0.0.0.0', '4.0.0.dev1']\n</code></pre>"},{"location":"refs/version/#feu.version.get_package_version","title":"feu.version.get_package_version","text":"<pre><code>get_package_version(package: str) -&gt; Version | None\n</code></pre> <p>Get the package version.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <p>Returns:</p> Type Description <code>Version | None</code> <p>The package version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import get_package_version\n&gt;&gt;&gt; get_package_version(\"pytest\")\n&lt;Version('...')&gt;\n</code></pre>"},{"location":"refs/version/#feu.version.get_python_major_minor","title":"feu.version.get_python_major_minor  <code>cached</code>","text":"<pre><code>get_python_major_minor() -&gt; str\n</code></pre> <p>Get the MAJOR.MINOR version of the current python.</p> <p>Returns:</p> Type Description <code>str</code> <p>The MAJOR.MINOR version of the current python.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import get_python_major_minor\n&gt;&gt;&gt; get_python_major_minor()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.latest_major_versions","title":"feu.version.latest_major_versions","text":"<pre><code>latest_major_versions(versions: Sequence[str]) -&gt; list[str]\n</code></pre> <p>Return the latest version for each major version in a list of semantic versions.</p> <p>This function takes a list of semantic version strings (e.g. \"1.0.0\", \"1.2.1\", \"2.0.0\"), groups them by their major version number, and returns only the latest version from each major group (based on minor and patch numbers).</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings in semantic version format.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list containing the latest version for each major version, sorted by major version number.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import latest_major_versions\n&gt;&gt;&gt; versions = latest_major_versions([\"1.0.0\", \"1.1.0\", \"1.2.0\", \"1.2.1\", \"2.0.0\"])\n&gt;&gt;&gt; versions\n['1.2.1', '2.0.0']\n</code></pre>"},{"location":"refs/version/#feu.version.latest_minor_versions","title":"feu.version.latest_minor_versions","text":"<pre><code>latest_minor_versions(versions: Sequence[str]) -&gt; list[str]\n</code></pre> <p>Return the latest version for each minor version in a list of semantic versions.</p> <p>This function takes a list of semantic version strings (e.g. \"1.0.0\", \"1.0.1\", \"1.1.0\", \"2.0.0\"), groups them by their major and minor version numbers, and returns only the latest version from each minor group (based on the patch number).</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings in semantic version format.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list containing the latest version for each minor version, sorted by major and minor version numbers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import latest_major_versions\n&gt;&gt;&gt; versions = latest_minor_versions([\"1.0.0\", \"1.0.1\", \"1.1.0\", \"1.1.2\", \"2.0.0\", \"2.0.3\"])\n&gt;&gt;&gt; versions\n['1.0.1', '1.1.2', '2.0.3']\n</code></pre>"},{"location":"refs/version/#feu.version.latest_version","title":"feu.version.latest_version","text":"<pre><code>latest_version(versions: Sequence[str]) -&gt; str\n</code></pre> <p>Return the latest version string in a list of version identifiers.</p> <p>This function compares version strings according to the PEP 440 specification using :class:<code>packaging.version.Version</code>. It supports standard releases, pre-releases (alpha, beta, release candidates), development releases, post releases, and epoch-based versions.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings to compare.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The highest (latest) version in the list based on PEP 440 ordering.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>versions</code> is empty.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; from feu.version import latest_version\n&gt;&gt;&gt; latest_version([\"1.0.0\", \"1.0.1rc1\", \"1.0.1\"])\n'1.0.1'\n&gt;&gt;&gt; latest_version([\"1.2.0\", \"2.0.0a1\"])\n'2.0.0a1'\n</code></pre>"},{"location":"refs/version/#feu.version.sort_versions","title":"feu.version.sort_versions","text":"<pre><code>sort_versions(\n    versions: Sequence[str], reverse: bool = False\n) -&gt; list[str]\n</code></pre> <p>Sort a list of version strings in ascending or descending order.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <code>reverse</code> <code>bool</code> <p>If <code>False</code>, sort in ascending order; if <code>True</code>, sort in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A new list of version strings sorted according to semantic version order.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; from feu.version import sort_versions\n&gt;&gt;&gt; sort_versions([\"1.0.0\", \"1.2.0\", \"1.1.0\"])\n['1.0.0', '1.1.0', '1.2.0']\n&gt;&gt;&gt; sort_versions([\"1.0.0\", \"1.2.0\", \"1.1.0\"], reverse=True)\n['1.2.0', '1.1.0', '1.0.0']\n</code></pre>"},{"location":"refs/version/#feu.version.unique_versions","title":"feu.version.unique_versions","text":"<pre><code>unique_versions(versions: Sequence[str]) -&gt; list[str]\n</code></pre> <p>Return a list of unique versions while preserving order.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list containing only unique version strings, preserving the original order of first occurrence.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import unique_versions, sort_versions\n&gt;&gt;&gt; versions = sort_versions(unique_versions([\"1.0.0\", \"1.0.1\", \"1.0.0\", \"1.2.0\"]))\n&gt;&gt;&gt; versions\n['1.0.0', '1.0.1', '1.2.0']\n</code></pre>"}]}