{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>feu</code> (French word for \"fire\" \ud83d\udd25) is a lightweight Python library designed to help manage Python packages and their versions across different Python environments. It provides utilities to:</p> <ul> <li>Check package availability: Verify if packages and modules are available in your environment</li> <li>Install packages intelligently: Install packages with version compatibility checks for your Python version</li> <li>Version management: Find the closest valid package version for your Python environment</li> <li>Package configuration: Maintain a registry of known package version compatibility with different Python versions</li> </ul> <p>The library is particularly useful for projects that need to support multiple Python versions and want to ensure they install compatible package versions.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Python version-aware: Automatically selects compatible package versions based on your Python version</li> <li>CLI interface: Command-line tools for package management tasks</li> <li>Lightweight: Minimal dependencies (only <code>packaging</code> required for core functionality)</li> <li>Extensible: Registry of common packages (numpy, pandas, torch, etc.) with known version constraints</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from feu import is_package_available, install_package_closest_version\nfrom feu.package import find_closest_version\n\n# Check if a package is available\nif is_package_available(\"numpy\"):\n    print(\"NumPy is installed!\")\n\n# Find the closest valid version for your Python version\nversion = find_closest_version(\n    pkg_name=\"numpy\", pkg_version=\"2.0.2\", python_version=\"3.10\"\n)\nprint(f\"Closest valid version: {version}\")\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>feu</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>feu</code> to a new version will possibly break any code that was using the old version of <code>feu</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>feu</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<p><code>feu</code> provides a command-line interface (CLI) for package management tasks. To use the CLI, you need to install the optional <code>cli</code> dependency:</p> <pre><code>pip install 'feu[cli]'\n</code></pre>"},{"location":"cli/#available-commands","title":"Available Commands","text":"<p>The CLI provides three main commands:</p> <ol> <li><code>install</code> - Install a package with version compatibility checks</li> <li><code>find-closest-version</code> - Find the closest valid version for a package</li> <li><code>check-valid-version</code> - Check if a package version is valid for a Python version</li> </ol>"},{"location":"cli/#install-command","title":"Install Command","text":"<p>Install a package with automatic version compatibility handling for your Python environment.</p>"},{"location":"cli/#syntax","title":"Syntax","text":"<pre><code>python -m feu install [OPTIONS]\n</code></pre>"},{"location":"cli/#options","title":"Options","text":"<ul> <li><code>-n, --pkg-name TEXT</code> - Package name (required)</li> <li><code>-v, --pkg-version TEXT</code> - Package version (required)</li> <li><code>-e, --pkg-extras TEXT</code> - Package extra dependencies (optional, comma-separated)</li> <li><code>-i, --installer-name TEXT</code> - Installer name (default: \"pip\")</li> <li><code>-a, --installer-args TEXT</code> - Installer arguments (optional)</li> </ul>"},{"location":"cli/#examples","title":"Examples","text":"<p>Install NumPy version 2.0.2:</p> <pre><code>python -m feu install --pkg-name=numpy --pkg-version=2.0.2\n</code></pre> <p>Install NumPy with specific extras:</p> <pre><code>python -m feu install --pkg-name=numpy --pkg-version=2.0.2 --pkg-extras=dev,doc\n</code></pre> <p>Install with custom installer arguments:</p> <pre><code>python -m feu install \\\n  --pkg-name=numpy \\\n  --pkg-version=2.0.2 \\\n  --installer-name=pip \\\n  --installer-args=\"--upgrade --no-cache-dir\"\n</code></pre>"},{"location":"cli/#find-closest-version-command","title":"Find Closest Version Command","text":"<p>Find the closest valid version of a package for a specific Python version.</p>"},{"location":"cli/#syntax_1","title":"Syntax","text":"<pre><code>python -m feu find-closest-version [OPTIONS]\n</code></pre>"},{"location":"cli/#options_1","title":"Options","text":"<ul> <li><code>-n, --pkg-name TEXT</code> - Package name (required)</li> <li><code>-v, --pkg-version TEXT</code> - Package version to check (required)</li> <li><code>-p, --python-version TEXT</code> - Python version (required, e.g., \"3.10\", \"3.11\")</li> </ul>"},{"location":"cli/#examples_1","title":"Examples","text":"<p>Find the closest valid NumPy version for Python 3.10:</p> <pre><code>python -m feu find-closest-version \\\n  --pkg-name=numpy \\\n  --pkg-version=2.0.2 \\\n  --python-version=3.10\n</code></pre> <p>Output: <pre><code>2.0.2\n</code></pre></p> <p>Check what version would be used for an older NumPy version on Python 3.11:</p> <pre><code>python -m feu find-closest-version \\\n  --pkg-name=numpy \\\n  --pkg-version=1.0.0 \\\n  --python-version=3.11\n</code></pre> <p>Output: <pre><code>1.23.2\n</code></pre></p> <p>This shows that NumPy 1.0.0 is too old for Python 3.11, so the minimum supported version (1.23.2) would be used instead.</p>"},{"location":"cli/#check-valid-version-command","title":"Check Valid Version Command","text":"<p>Check if a specific package version is valid for a given Python version.</p>"},{"location":"cli/#syntax_2","title":"Syntax","text":"<pre><code>python -m feu check-valid-version [OPTIONS]\n</code></pre>"},{"location":"cli/#options_2","title":"Options","text":"<ul> <li><code>-n, --pkg-name TEXT</code> - Package name (required)</li> <li><code>-v, --pkg-version TEXT</code> - Package version to check (required)</li> <li><code>-p, --python-version TEXT</code> - Python version (required, e.g., \"3.10\", \"3.11\")</li> </ul>"},{"location":"cli/#examples_2","title":"Examples","text":"<p>Check if NumPy 2.0.2 is valid for Python 3.10:</p> <pre><code>python -m feu check-valid-version \\\n  --pkg-name=numpy \\\n  --pkg-version=2.0.2 \\\n  --python-version=3.10\n</code></pre> <p>Output: <pre><code>True\n</code></pre></p> <p>Check if NumPy 1.0.0 is valid for Python 3.11:</p> <pre><code>python -m feu check-valid-version \\\n  --pkg-name=numpy \\\n  --pkg-version=1.0.0 \\\n  --python-version=3.11\n</code></pre> <p>Output: <pre><code>False\n</code></pre></p>"},{"location":"cli/#practical-workflows","title":"Practical Workflows","text":""},{"location":"cli/#workflow-1-verify-before-install","title":"Workflow 1: Verify Before Install","text":"<p>Before installing a package, check if the version is compatible:</p> <pre><code># Check compatibility\nVALID=$(python -m feu check-valid-version \\\n  --pkg-name=numpy \\\n  --pkg-version=2.0.2 \\\n  --python-version=3.10)\n\nif [ \"$VALID\" = \"True\" ]; then\n  echo \"Version is compatible, proceeding with installation...\"\n  python -m feu install --pkg-name=numpy --pkg-version=2.0.2\nelse\n  echo \"Version is not compatible, finding closest version...\"\n  VERSION=$(python -m feu find-closest-version \\\n    --pkg-name=numpy \\\n    --pkg-version=2.0.2 \\\n    --python-version=3.10)\n  echo \"Installing version $VERSION instead\"\n  python -m feu install --pkg-name=numpy --pkg-version=$VERSION\nfi\n</code></pre>"},{"location":"cli/#workflow-2-batch-installation","title":"Workflow 2: Batch Installation","text":"<p>Install multiple packages with compatibility checks:</p> <pre><code>#!/bin/bash\n\nPACKAGES=(\n  \"numpy:2.0.2\"\n  \"pandas:2.0.0\"\n  \"scipy:1.10.0\"\n)\n\nPYTHON_VERSION=\"3.10\"\n\nfor pkg in \"${PACKAGES[@]}\"; do\n  IFS=':' read -r name version &lt;&lt;&lt; \"$pkg\"\n\n  echo \"Processing $name $version...\"\n\n  closest=$(python -m feu find-closest-version \\\n    --pkg-name=$name \\\n    --pkg-version=$version \\\n    --python-version=$PYTHON_VERSION)\n\n  echo \"Installing $name $closest\"\n  python -m feu install --pkg-name=$name --pkg-version=$closest\ndone\n</code></pre>"},{"location":"cli/#workflow-3-cicd-integration","title":"Workflow 3: CI/CD Integration","text":"<p>Use in continuous integration to ensure compatible versions:</p> <pre><code># .github/workflows/install-deps.yml\nname: Install Dependencies\n\non: [push, pull_request]\n\njobs:\n  install:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.10', '3.11', '3.12', '3.13']\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install feu\n        run: pip install 'feu[cli]'\n\n      - name: Install numpy with version check\n        run: |\n          python -m feu install \\\n            --pkg-name=numpy \\\n            --pkg-version=2.0.2\n</code></pre>"},{"location":"cli/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li> <p>Always specify Python version: When using <code>find-closest-version</code> or <code>check-valid-version</code>, make sure to specify the correct Python version you're targeting.</p> </li> <li> <p>Use extras for optional dependencies: When installing packages with optional features, use the <code>--pkg-extras</code> flag to include them.</p> </li> <li> <p>Combine with pip options: Use <code>--installer-args</code> to pass additional pip options like <code>--upgrade</code>, <code>--no-deps</code>, or <code>--no-cache-dir</code>.</p> </li> <li> <p>Script automation: The CLI commands are designed to be easily integrated into shell scripts and CI/CD pipelines.</p> </li> <li> <p>Version checking: Always use <code>check-valid-version</code> before attempting installation in production environments to avoid runtime errors.</p> </li> </ol>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install feu\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>feu</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'feu[all]'\n</code></pre> <p>It is also possible to install specific optional dependencies:</p> <ul> <li><code>feu[cli]</code> - Install CLI support (click)</li> <li><code>feu[git]</code> - Install git support (gitpython)</li> <li><code>feu[requests]</code> - Install HTTP request support (requests, urllib3)</li> </ul> <p>For example:</p> <pre><code>pip install 'feu[cli,git]'\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>feu</code> from source, you can follow the steps below. First, you will need to install <code>uv</code>. <code>uv</code> is a fast Python package installer and resolver used to manage dependencies in this project.</p> <p>You can install <code>uv</code> using:</p> <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Or with pip\npip install uv\n</code></pre> <p>Then, clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/feu.git\ncd feu\n</code></pre> <p>It is recommended to create a Python 3.10+ virtual environment. The easiest way is to use the provided Makefile command:</p> <pre><code>make setup-venv\n</code></pre> <p>This command automatically: 1. Updates <code>uv</code> to the latest version 2. Creates a Python 3.13 virtual environment 3. Installs <code>invoke</code> task runner 4. Installs all dependencies including development and documentation dependencies</p> <p>Alternatively, you can manually set up the environment:</p> <pre><code># Create a virtual environment with uv\nuv venv --python 3.13\n\n# Activate the virtual environment\nsource .venv/bin/activate\n\n# Install the package with all dependencies\nuv sync --all-extras --group dev --group docs\n</code></pre> <p>After installation, you can verify everything is working by running the tests:</p> <pre><code>inv unit-test --cov\n</code></pre>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide demonstrates the main features and use cases of <code>feu</code>.</p>"},{"location":"usage/#checking-package-availability","title":"Checking Package Availability","text":"<p>You can check if packages or modules are available in your environment:</p> <pre><code>from feu import is_package_available, is_module_available\n\n# Check if a package is installed\nif is_package_available(\"numpy\"):\n    print(\"NumPy is available!\")\nelse:\n    print(\"NumPy is not installed\")\n\n# Check if a specific module is available\nif is_module_available(\"numpy.linalg\"):\n    print(\"NumPy linear algebra module is available!\")\n</code></pre>"},{"location":"usage/#version-comparison","title":"Version Comparison","text":"<p>Compare package versions to determine compatibility:</p> <pre><code>from feu import compare_version\n\n# Compare versions\nresult = compare_version(\"2.0.0\", \"1.5.0\")\nprint(result)  # Returns 1 (first version is greater)\n\nresult = compare_version(\"1.0.0\", \"2.0.0\")\nprint(result)  # Returns -1 (first version is less)\n\nresult = compare_version(\"1.5.0\", \"1.5.0\")\nprint(result)  # Returns 0 (versions are equal)\n</code></pre>"},{"location":"usage/#getting-package-version","title":"Getting Package Version","text":"<p>Retrieve the installed version of a package:</p> <pre><code>from feu import get_package_version\n\n# Get the version of an installed package\nversion = get_package_version(\"numpy\")\nprint(f\"NumPy version: {version}\")\n</code></pre>"},{"location":"usage/#finding-compatible-versions","title":"Finding Compatible Versions","text":"<p>Find the closest valid package version for your Python version:</p> <pre><code>from feu.package import find_closest_version, is_valid_version\n\n# Check if a specific version is valid for your Python version\nis_valid = is_valid_version(\n    pkg_name=\"numpy\", pkg_version=\"2.0.2\", python_version=\"3.10\"\n)\nprint(f\"NumPy 2.0.2 is valid for Python 3.10: {is_valid}\")\n\n# Find the closest valid version\nclosest = find_closest_version(\n    pkg_name=\"numpy\",\n    pkg_version=\"1.0.0\",  # This is too old for Python 3.11\n    python_version=\"3.11\",\n)\nprint(f\"Closest valid version: {closest}\")  # Will return \"1.23.2\"\n</code></pre>"},{"location":"usage/#installing-packages","title":"Installing Packages","text":"<p>Install packages with automatic version selection:</p> <pre><code>from feu import install_package, install_package_closest_version\nfrom feu.utils.package import PackageSpec\nfrom feu.utils.installer import InstallerSpec\n\n# Install a package with a specific version\ninstall_package(\n    installer=InstallerSpec(name=\"pip\"),\n    package=PackageSpec(name=\"numpy\", version=\"2.0.2\"),\n)\n\n# Install the closest valid version for your Python environment\ninstall_package_closest_version(\n    installer=InstallerSpec(name=\"pip\"),\n    package=PackageSpec(name=\"numpy\", version=\"2.0.2\"),\n)\n</code></pre>"},{"location":"usage/#managing-package-configurations","title":"Managing Package Configurations","text":"<p>Add custom package configurations to the registry:</p> <pre><code>from feu.package import PackageConfig\n\n# Add a custom package configuration\nPackageConfig.add_config(\n    pkg_name=\"my_package\",\n    python_version=\"3.11\",\n    pkg_version_min=\"1.2.0\",\n    pkg_version_max=\"2.0.0\",\n    exist_ok=True,\n)\n\n# Get the configuration for a package\nconfig = PackageConfig.get_config(pkg_name=\"my_package\", python_version=\"3.11\")\nprint(config)  # {'min': '1.2.0', 'max': '2.0.0'}\n\n# Get min and max versions\nmin_version, max_version = PackageConfig.get_min_and_max_versions(\n    pkg_name=\"numpy\", python_version=\"3.11\"\n)\nprint(f\"Min: {min_version}, Max: {max_version}\")\n</code></pre>"},{"location":"usage/#working-with-git-repositories","title":"Working with Git Repositories","text":"<p>If you have installed the <code>git</code> extra (<code>pip install 'feu[git]'</code>), you can work with git repositories:</p> <pre><code>from feu.git import get_git_branch, get_git_last_commit_hash\n\n# Get the current git branch\nbranch = get_git_branch()\nprint(f\"Current branch: {branch}\")\n\n# Get the last commit hash\ncommit_hash = get_git_last_commit_hash()\nprint(f\"Last commit: {commit_hash}\")\n</code></pre>"},{"location":"usage/#supported-packages","title":"Supported Packages","text":"<p><code>feu</code> includes built-in version compatibility information for common packages:</p> <ul> <li>Scientific Computing: numpy, scipy, pandas, xarray</li> <li>Machine Learning: torch, jax, scikit-learn</li> <li>Data Handling: pyarrow</li> <li>Visualization: matplotlib</li> <li>Web: requests, click</li> </ul> <p>Each package has defined minimum and maximum versions for different Python versions (3.9, 3.10, 3.11, 3.12, 3.13, 3.14).</p>"},{"location":"usage/#testing-utilities","title":"Testing Utilities","text":"<p><code>feu</code> provides testing utilities for checking package availability in tests:</p> <pre><code>from feu.testing import (\n    click_available,\n    gitpython_available,\n    requests_available,\n)\n\n\n# Use as decorators in pytest\n@click_available\ndef test_click_feature():\n    # This test only runs if click is available\n    pass\n\n\n@gitpython_available\ndef test_git_feature():\n    # This test only runs if gitpython is available\n    pass\n\n\n@requests_available\ndef test_http_feature():\n    # This test only runs if requests is available\n    pass\n</code></pre>"},{"location":"usage/#common-use-cases","title":"Common Use Cases","text":""},{"location":"usage/#use-case-1-multi-python-version-project","title":"Use Case 1: Multi-Python Version Project","text":"<p>If you're maintaining a project that supports multiple Python versions:</p> <pre><code>import sys\nfrom feu.package import find_closest_version\n\npython_version = f\"{sys.version_info.major}.{sys.version_info.minor}\"\n\n# Find compatible numpy version\nnumpy_version = find_closest_version(\n    pkg_name=\"numpy\", pkg_version=\"2.0.0\", python_version=python_version\n)\nprint(f\"Installing numpy {numpy_version} for Python {python_version}\")\n</code></pre>"},{"location":"usage/#use-case-2-safe-package-installation","title":"Use Case 2: Safe Package Installation","text":"<p>Before installing a package, check if the version is compatible:</p> <pre><code>import sys\nfrom feu.package import is_valid_version\nfrom feu import install_package\nfrom feu.utils.package import PackageSpec\nfrom feu.utils.installer import InstallerSpec\n\npython_version = f\"{sys.version_info.major}.{sys.version_info.minor}\"\ndesired_version = \"2.0.2\"\n\nif is_valid_version(\"numpy\", desired_version, python_version):\n    install_package(\n        installer=InstallerSpec(name=\"pip\"),\n        package=PackageSpec(name=\"numpy\", version=desired_version),\n    )\nelse:\n    print(f\"Version {desired_version} is not compatible with Python {python_version}\")\n</code></pre>"},{"location":"usage/#use-case-3-conditional-imports","title":"Use Case 3: Conditional Imports","text":"<p>Use package availability checks for conditional imports:</p> <pre><code>from feu import is_package_available\n\nif is_package_available(\"torch\"):\n    import torch\n\n    USE_PYTORCH = True\nelse:\n    USE_PYTORCH = False\n    print(\"PyTorch not available, using fallback implementation\")\n</code></pre>"},{"location":"refs/git/","title":"Git","text":""},{"location":"refs/git/#feu.git","title":"feu.git","text":"<p>Contain git utility functions.</p>"},{"location":"refs/git/#feu.git.get_last_tag_name","title":"feu.git.get_last_tag_name","text":"<pre><code>get_last_tag_name() -&gt; str\n</code></pre> <p>Get the name of the most recent tag in the current repository.</p> <p>Returns:</p> Type Description <code>str</code> <p>The tag name.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.git import get_last_tag_name\n&gt;&gt;&gt; tag = get_last_tag_name()\n&gt;&gt;&gt; tag\n</code></pre>"},{"location":"refs/git/#feu.git.get_last_version_tag_name","title":"feu.git.get_last_version_tag_name","text":"<pre><code>get_last_version_tag_name() -&gt; str\n</code></pre> <p>Get the name of the most recent version tag in the current repository.</p> <p>A version tag is a tag starting with <code>v{number}*</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>The tag name.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.git import get_last_version_tag_name\n&gt;&gt;&gt; tag = get_last_version_tag_name()\n&gt;&gt;&gt; tag\n</code></pre>"},{"location":"refs/git/#feu.git.get_tags","title":"feu.git.get_tags","text":"<pre><code>get_tags() -&gt; list[TagReference]\n</code></pre> <p>Get the list of git tags sorted by date/time for the current repository.</p> <p>Returns:</p> Type Description <code>list[TagReference]</code> <p>The list of git tags sorted by date/time.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.git import get_tags\n&gt;&gt;&gt; tags = get_tags()\n&gt;&gt;&gt; tags\n</code></pre>"},{"location":"refs/imports/","title":"Imports","text":""},{"location":"refs/imports/#feu.imports","title":"feu.imports","text":"<p>Contain to check if a package or module is available.</p>"},{"location":"refs/imports/#feu.imports.check_click","title":"feu.imports.check_click","text":"<pre><code>check_click() -&gt; None\n</code></pre> <p>Check if the <code>click</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>click</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import check_click\n&gt;&gt;&gt; check_click()\n</code></pre>"},{"location":"refs/imports/#feu.imports.check_git","title":"feu.imports.check_git","text":"<pre><code>check_git() -&gt; None\n</code></pre> <p>Check if the <code>git</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>git</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import check_git\n&gt;&gt;&gt; check_git()\n</code></pre>"},{"location":"refs/imports/#feu.imports.check_requests","title":"feu.imports.check_requests","text":"<pre><code>check_requests() -&gt; None\n</code></pre> <p>Check if the <code>requests</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>requests</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import check_requests\n&gt;&gt;&gt; check_requests()\n</code></pre>"},{"location":"refs/imports/#feu.imports.check_urllib3","title":"feu.imports.check_urllib3","text":"<pre><code>check_urllib3() -&gt; None\n</code></pre> <p>Check if the <code>urllib3</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>urllib3</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import check_urllib3\n&gt;&gt;&gt; check_urllib3()\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_click_available","title":"feu.imports.is_click_available  <code>cached</code>","text":"<pre><code>is_click_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>click</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>click</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import is_click_available\n&gt;&gt;&gt; is_click_available()\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_git_available","title":"feu.imports.is_git_available  <code>cached</code>","text":"<pre><code>is_git_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>git</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>git</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import is_git_available\n&gt;&gt;&gt; is_git_available()\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_module_available","title":"feu.imports.is_module_available  <code>cached</code>","text":"<pre><code>is_module_available(module: str) -&gt; bool\n</code></pre> <p>Check if a module path is available.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>str</code> <p>The module to check.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu import is_module_available\n&gt;&gt;&gt; is_module_available(\"os\")\nTrue\n&gt;&gt;&gt; is_module_available(\"os.path\")\nTrue\n&gt;&gt;&gt; is_module_available(\"missing.module\")\nFalse\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_package_available","title":"feu.imports.is_package_available  <code>cached</code>","text":"<pre><code>is_package_available(package: str) -&gt; bool\n</code></pre> <p>Check if a package is available.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the package is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu import is_package_available\n&gt;&gt;&gt; is_package_available(\"os\")\nTrue\n&gt;&gt;&gt; is_package_available(\"os.path\")\nTrue\n&gt;&gt;&gt; is_package_available(\"my_missing_package\")\nFalse\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_requests_available","title":"feu.imports.is_requests_available  <code>cached</code>","text":"<pre><code>is_requests_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>requests</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>requests</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import is_requests_available\n&gt;&gt;&gt; is_requests_available()\n</code></pre>"},{"location":"refs/imports/#feu.imports.is_urllib3_available","title":"feu.imports.is_urllib3_available  <code>cached</code>","text":"<pre><code>is_urllib3_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>urllib3</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>urllib3</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.imports import is_urllib3_available\n&gt;&gt;&gt; is_urllib3_available()\n</code></pre>"},{"location":"refs/imports/#feu.imports.raise_error_click_missing","title":"feu.imports.raise_error_click_missing","text":"<pre><code>raise_error_click_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>click</code> package is missing.</p>"},{"location":"refs/imports/#feu.imports.raise_error_git_missing","title":"feu.imports.raise_error_git_missing","text":"<pre><code>raise_error_git_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>git</code> package is missing.</p>"},{"location":"refs/imports/#feu.imports.raise_error_requests_missing","title":"feu.imports.raise_error_requests_missing","text":"<pre><code>raise_error_requests_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>requests</code> package is missing.</p>"},{"location":"refs/imports/#feu.imports.raise_error_urllib3_missing","title":"feu.imports.raise_error_urllib3_missing","text":"<pre><code>raise_error_urllib3_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>urllib3</code> package is missing.</p>"},{"location":"refs/install/","title":"Install","text":""},{"location":"refs/install/#feu.install","title":"feu.install","text":"<p>Contain package installers.</p>"},{"location":"refs/install/#feu.install.BaseInstaller","title":"feu.install.BaseInstaller","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipInstaller()\n&gt;&gt;&gt; installer\nPipInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.BaseInstaller.equal","title":"feu.install.BaseInstaller.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two installers are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two installers are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; obj1 = PipInstaller()\n&gt;&gt;&gt; obj2 = PipInstaller()\n&gt;&gt;&gt; obj3 = PipInstaller(\"-U\")\n&gt;&gt;&gt; obj1.equal(obj2)\nTrue\n&gt;&gt;&gt; obj1.equal(obj3)\nFalse\n</code></pre>"},{"location":"refs/install/#feu.install.BaseInstaller.install","title":"feu.install.BaseInstaller.install  <code>abstractmethod</code>","text":"<pre><code>install(package: PackageSpec) -&gt; None\n</code></pre> <p>Install the given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>PackageSpec</code> <p>The package specification of the package to install.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipInstaller()\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.BaseInstaller.instantiate_with_arguments","title":"feu.install.BaseInstaller.instantiate_with_arguments  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>instantiate_with_arguments(arguments: str) -&gt; Self\n</code></pre> <p>Instantiate an installer instance with custom arguments.</p> <p>Parameters:</p> Name Type Description Default <code>arguments</code> <code>str</code> <p>The installer arguments.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An instantiated installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; installer = PipInstaller.instantiate_with_arguments(\"-U\")\n&gt;&gt;&gt; installer\nPipInstaller(arguments='-U')\n</code></pre>"},{"location":"refs/install/#feu.install.InstallerRegistry","title":"feu.install.InstallerRegistry","text":"<p>Implement the main installer registry.</p>"},{"location":"refs/install/#feu.install.InstallerRegistry.add_installer","title":"feu.install.InstallerRegistry.add_installer  <code>classmethod</code>","text":"<pre><code>add_installer(\n    name: str,\n    installer: type[BaseInstaller],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an installer for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The installer name e.g. pip or uv.</p> required <code>installer</code> <code>type[BaseInstaller]</code> <p>The installer used for the given package.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the installer already exists. This parameter should be set to <code>True</code> to overwrite the installer for a package.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an installer is already registered for the package name and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import InstallerRegistry\n&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; InstallerRegistry.add_installer(\"pip\", PipInstaller, exist_ok=True)\n</code></pre>"},{"location":"refs/install/#feu.install.InstallerRegistry.has_installer","title":"feu.install.InstallerRegistry.has_installer  <code>classmethod</code>","text":"<pre><code>has_installer(name: str) -&gt; bool\n</code></pre> <p>Indicate if an installer is registered for the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The installer name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an installer is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import InstallerRegistry\n&gt;&gt;&gt; InstallerRegistry.has_installer(\"pip\")\nTrue\n</code></pre>"},{"location":"refs/install/#feu.install.InstallerRegistry.install","title":"feu.install.InstallerRegistry.install  <code>classmethod</code>","text":"<pre><code>install(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package and associated packages by using the specified installer.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import InstallerRegistry\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; InstallerRegistry.install(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.get_available_installers","title":"feu.install.get_available_installers  <code>cached</code>","text":"<pre><code>get_available_installers() -&gt; tuple[str, ...]\n</code></pre> <p>Get the available installers.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The available installers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import get_available_installers\n&gt;&gt;&gt; get_available_installers()\n(...)\n</code></pre>"},{"location":"refs/install/#feu.install.install_package","title":"feu.install.install_package","text":"<pre><code>install_package(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package with the specified installer.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.install_package_closest_version","title":"feu.install.install_package_closest_version","text":"<pre><code>install_package_closest_version(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package and associated packages by using the secified installer.</p> <p>This function finds the closest valid version if the specified version is not compatible.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no package version is specified.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package_closest_version\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package_closest_version(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.is_pip_available","title":"feu.install.is_pip_available  <code>cached</code>","text":"<pre><code>is_pip_available() -&gt; bool\n</code></pre> <p>Check if <code>pip</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pip</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_pip_available\n&gt;&gt;&gt; is_pip_available()\n</code></pre>"},{"location":"refs/install/#feu.install.is_pipx_available","title":"feu.install.is_pipx_available  <code>cached</code>","text":"<pre><code>is_pipx_available() -&gt; bool\n</code></pre> <p>Check if <code>pipx</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pipx</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_pipx_available\n&gt;&gt;&gt; is_pipx_available()\n</code></pre>"},{"location":"refs/install/#feu.install.is_uv_available","title":"feu.install.is_uv_available  <code>cached</code>","text":"<pre><code>is_uv_available() -&gt; bool\n</code></pre> <p>Check if <code>uv</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>uv</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_uv_available\n&gt;&gt;&gt; is_uv_available()\n</code></pre>"},{"location":"refs/install/#feu.install.pip","title":"feu.install.pip","text":"<p>Contain functionalities to install packages with pip or compatible package installers.</p>"},{"location":"refs/install/#feu.install.pip.PipInstaller","title":"feu.install.pip.PipInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a pip package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipInstaller()\n&gt;&gt;&gt; installer\nPipInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.PipxInstaller","title":"feu.install.pip.PipxInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a pipx package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipxInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipxInstaller()\n&gt;&gt;&gt; installer\nPipxInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.UvInstaller","title":"feu.install.pip.UvInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a uv package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import UvInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = UvInstaller()\n&gt;&gt;&gt; installer\nUvInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.installer","title":"feu.install.pip.installer","text":"<p>Define the pip compatible installers.</p>"},{"location":"refs/install/#feu.install.pip.installer.BasePipInstaller","title":"feu.install.pip.installer.BasePipInstaller","text":"<p>               Bases: <code>BaseInstaller</code></p> <p>Define an intermediate base class to implement pip compatible package installer.</p> <p>Parameters:</p> Name Type Description Default <code>arguments</code> <code>str</code> <p>Optional arguments to pass to the package installer. The valid arguments depend on the package installer.</p> <code>''</code> <p>Example usage (subclassing):</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.installer import BasePipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec, PackageDependency\n&gt;&gt;&gt; class MyInstaller(BasePipInstaller):\n...     def _generate_command(self, deps, args):\n...         return f\"echo Installing {', '.join(map(str, deps))} with args: {args}\"\n...\n&gt;&gt;&gt; installer = MyInstaller(arguments=\"--verbose\")\n&gt;&gt;&gt; installer\nMyInstaller(arguments='--verbose')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.installer.PipInstaller","title":"feu.install.pip.installer.PipInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a pip package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipInstaller()\n&gt;&gt;&gt; installer\nPipInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.installer.PipxInstaller","title":"feu.install.pip.installer.PipxInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a pipx package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import PipxInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = PipxInstaller()\n&gt;&gt;&gt; installer\nPipxInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.installer.UvInstaller","title":"feu.install.pip.installer.UvInstaller","text":"<p>               Bases: <code>BasePipInstaller</code></p> <p>Implement a uv package installer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip import UvInstaller\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; installer = UvInstaller()\n&gt;&gt;&gt; installer\nUvInstaller(arguments='')\n&gt;&gt;&gt; installer.install(PackageSpec(name=\"pandas\", version=\"2.2.2\"))  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver","title":"feu.install.pip.resolver","text":"<p>Contain pip compatible package dependency resolvers.</p>"},{"location":"refs/install/#feu.install.pip.resolver.BaseDependencyResolver","title":"feu.install.pip.resolver.BaseDependencyResolver","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class for pip-compatible package dependency resolvers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = DependencyResolver()\n&gt;&gt;&gt; resolver\nDependencyResolver()\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"my_package\", version=\"1.2.3\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.BaseDependencyResolver.equal","title":"feu.install.pip.resolver.BaseDependencyResolver.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two dependency resolvers are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two dependency resolvers are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolver, TorchDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; obj1 = DependencyResolver()\n&gt;&gt;&gt; obj2 = DependencyResolver()\n&gt;&gt;&gt; obj3 = TorchDependencyResolver()\n&gt;&gt;&gt; obj1.equal(obj2)\nTrue\n&gt;&gt;&gt; obj1.equal(obj3)\nFalse\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.BaseDependencyResolver.resolve","title":"feu.install.pip.resolver.BaseDependencyResolver.resolve  <code>abstractmethod</code>","text":"<pre><code>resolve(package: PackageSpec) -&gt; list[PackageDependency]\n</code></pre> <p>Find the dependency packages to install a specific package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>PackageSpec</code> <p>The target package to install.</p> required <p>Returns:</p> Type Description <code>list[PackageDependency]</code> <p>The list of package dependencies.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = DependencyResolver()\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"my_package\", version=\"1.2.3\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.DependencyResolver","title":"feu.install.pip.resolver.DependencyResolver","text":"<p>               Bases: <code>BaseDependencyResolver</code></p> <p>Define the default package dependency resolver.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = DependencyResolver()\n&gt;&gt;&gt; resolver\nDependencyResolver()\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"my_package\", version=\"1.2.3\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.DependencyResolverRegistry","title":"feu.install.pip.resolver.DependencyResolverRegistry","text":"<p>Implement the main dependency resolver registry.</p> <p>The dependency resolvers are indexed by name.</p>"},{"location":"refs/install/#feu.install.pip.resolver.DependencyResolverRegistry.add_resolver","title":"feu.install.pip.resolver.DependencyResolverRegistry.add_resolver  <code>classmethod</code>","text":"<pre><code>add_resolver(\n    package: PackageSpec,\n    resolver: BaseDependencyResolver,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a dependency resolver for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <code>resolver</code> <code>BaseDependencyResolver</code> <p>The resolver used for the given package.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the package already exists. This parameter should be set to <code>True</code> to overwrite the resolver for a package.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a dependency resolver is already registered for the package name and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import (\n...     DependencyResolverRegistry,\n...     TorchDependencyResolver,\n... )\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; DependencyResolverRegistry.add_resolver(\n...     PackageSpec(\"torch\"), TorchDependencyResolver(), exist_ok=True\n... )\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.DependencyResolverRegistry.find_resolver","title":"feu.install.pip.resolver.DependencyResolverRegistry.find_resolver  <code>classmethod</code>","text":"<pre><code>find_resolver(\n    package: PackageSpec,\n) -&gt; BaseDependencyResolver\n</code></pre> <p>Find the relevant dependency resolver for the given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Returns:</p> Type Description <code>BaseDependencyResolver</code> <p>The dependency resolver for the package.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolverRegistry\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = DependencyResolverRegistry.find_resolver(PackageSpec(\"torch\"))\n&gt;&gt;&gt; resolver\nTorchDependencyResolver(min_version=2.3.0)\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.DependencyResolverRegistry.has_resolver","title":"feu.install.pip.resolver.DependencyResolverRegistry.has_resolver  <code>classmethod</code>","text":"<pre><code>has_resolver(package: PackageSpec) -&gt; bool\n</code></pre> <p>Indicate if a dependency resolver is registered for the given package specification.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a dependency resolver is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import DependencyResolverRegistry\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; DependencyResolverRegistry.has_resolver(PackageSpec(\"torch\"))\nTrue\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.JaxDependencyResolver","title":"feu.install.pip.resolver.JaxDependencyResolver","text":"<p>               Bases: <code>DependencyResolver</code></p> <p>Implement the <code>jax</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>jax</code> 0.4.26.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import JaxDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = JaxDependencyResolver()\n&gt;&gt;&gt; resolver\nJaxDependencyResolver()\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"jax\", version=\"0.4.26\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='jax', version_specifiers=['==0.4.26'], extras=None),\n PackageDependency(name='jaxlib', version_specifiers=['==0.4.26'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"jax\", version=\"0.4.25\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='jax', version_specifiers=['==0.4.25'], extras=None),\n PackageDependency(name='jaxlib', version_specifiers=['==0.4.25'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.MatplotlibDependencyResolver","title":"feu.install.pip.resolver.MatplotlibDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>matplotlib</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>matplotlib</code> 3.8.4.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import MatplotlibDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = MatplotlibDependencyResolver()\n&gt;&gt;&gt; resolver\nMatplotlibDependencyResolver(min_version=3.8.4)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"matplotlib\", version=\"3.8.4\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='matplotlib', version_specifiers=['==3.8.4'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"matplotlib\", version=\"3.8.3\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='matplotlib', version_specifiers=['==3.8.3'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.Numpy2DependencyResolver","title":"feu.install.pip.resolver.Numpy2DependencyResolver","text":"<p>               Bases: <code>DependencyResolver</code></p> <p>Define a dependency resolver to work with packages that did not pin <code>numpy&lt;2.0</code> and are not fully compatible with numpy 2.0.</p> <p>https://github.com/numpy/numpy/issues/26191 indicates the packages that are compatible with numpy 2.0.</p> <p>Parameters:</p> Name Type Description Default <code>min_version</code> <code>str</code> <p>The first version that is fully compatible with numpy 2.0.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import Numpy2DependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = Numpy2DependencyResolver(min_version=\"1.2.3\")\n&gt;&gt;&gt; resolver\nNumpy2DependencyResolver(min_version=1.2.3)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"my_package\", version=\"1.2.3\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"my_package\", version=\"1.2.2\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='my_package', version_specifiers=['==1.2.2'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.PandasDependencyResolver","title":"feu.install.pip.resolver.PandasDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>pandas</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>pandas</code> 2.2.2.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import PandasDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = PandasDependencyResolver()\n&gt;&gt;&gt; resolver\nPandasDependencyResolver(min_version=2.2.2)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"pandas\", version=\"2.2.2\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='pandas', version_specifiers=['==2.2.2'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"pandas\", version=\"2.2.1\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='pandas', version_specifiers=['==2.2.1'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.PyarrowDependencyResolver","title":"feu.install.pip.resolver.PyarrowDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>pyarrow</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>pyarrow</code> 16.0.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import PyarrowDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = PyarrowDependencyResolver()\n&gt;&gt;&gt; resolver\nPyarrowDependencyResolver(min_version=16.0)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"pyarrow\", version=\"16.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='pyarrow', version_specifiers=['==16.0'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"pyarrow\", version=\"15.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='pyarrow', version_specifiers=['==15.0'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.ScipyDependencyResolver","title":"feu.install.pip.resolver.ScipyDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>scipy</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>scipy</code> 1.13.0.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import ScipyDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = ScipyDependencyResolver()\n&gt;&gt;&gt; resolver\nScipyDependencyResolver(min_version=1.13.0)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"scipy\", version=\"1.13.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='scipy', version_specifiers=['==1.13.0'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"scipy\", version=\"1.12.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='scipy', version_specifiers=['==1.12.0'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.SklearnDependencyResolver","title":"feu.install.pip.resolver.SklearnDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>scikit-learn</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>scikit-learn</code> 1.4.2.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import SklearnDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = SklearnDependencyResolver()\n&gt;&gt;&gt; resolver\nSklearnDependencyResolver(min_version=1.4.2)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"scikit-learn\", version=\"1.4.2\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='scikit-learn', version_specifiers=['==1.4.2'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"scikit-learn\", version=\"1.4.1\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='scikit-learn', version_specifiers=['==1.4.1'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.TorchDependencyResolver","title":"feu.install.pip.resolver.TorchDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>torch</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>torch</code> 2.3.0.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import TorchDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = TorchDependencyResolver()\n&gt;&gt;&gt; resolver\nTorchDependencyResolver(min_version=2.3.0)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"torch\", version=\"2.3.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='torch', version_specifiers=['==2.3.0'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"torch\", version=\"2.2.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='torch', version_specifiers=['==2.2.0'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.pip.resolver.XarrayDependencyResolver","title":"feu.install.pip.resolver.XarrayDependencyResolver","text":"<p>               Bases: <code>Numpy2DependencyResolver</code></p> <p>Implement the <code>xarray</code> dependency resolver.</p> <p><code>numpy</code> 2.0 support was added in <code>xarray</code> 2024.6.0.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install.pip.resolver import XarrayDependencyResolver\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; resolver = XarrayDependencyResolver()\n&gt;&gt;&gt; resolver\nXarrayDependencyResolver(min_version=2024.6.0)\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"xarray\", version=\"2024.6.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='xarray', version_specifiers=['==2024.6.0'], extras=None)]\n&gt;&gt;&gt; deps = resolver.resolve(PackageSpec(name=\"xarray\", version=\"2024.5.0\"))\n&gt;&gt;&gt; deps\n[PackageDependency(name='xarray', version_specifiers=['==2024.5.0'], extras=None),\n PackageDependency(name='numpy', version_specifiers=['&lt;2.0.0'], extras=None)]\n</code></pre>"},{"location":"refs/install/#feu.install.utils","title":"feu.install.utils","text":"<p>Contain utility functions to install packages.</p>"},{"location":"refs/install/#feu.install.utils.get_available_installers","title":"feu.install.utils.get_available_installers  <code>cached</code>","text":"<pre><code>get_available_installers() -&gt; tuple[str, ...]\n</code></pre> <p>Get the available installers.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The available installers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import get_available_installers\n&gt;&gt;&gt; get_available_installers()\n(...)\n</code></pre>"},{"location":"refs/install/#feu.install.utils.install_package","title":"feu.install.utils.install_package","text":"<pre><code>install_package(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package with the specified installer.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.utils.install_package_closest_version","title":"feu.install.utils.install_package_closest_version","text":"<pre><code>install_package_closest_version(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package and associated packages by using the secified installer.</p> <p>This function finds the closest valid version if the specified version is not compatible.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no package version is specified.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package_closest_version\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package_closest_version(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/install/#feu.install.utils.is_pip_available","title":"feu.install.utils.is_pip_available  <code>cached</code>","text":"<pre><code>is_pip_available() -&gt; bool\n</code></pre> <p>Check if <code>pip</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pip</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_pip_available\n&gt;&gt;&gt; is_pip_available()\n</code></pre>"},{"location":"refs/install/#feu.install.utils.is_pipx_available","title":"feu.install.utils.is_pipx_available  <code>cached</code>","text":"<pre><code>is_pipx_available() -&gt; bool\n</code></pre> <p>Check if <code>pipx</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pipx</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_pipx_available\n&gt;&gt;&gt; is_pipx_available()\n</code></pre>"},{"location":"refs/install/#feu.install.utils.is_uv_available","title":"feu.install.utils.is_uv_available  <code>cached</code>","text":"<pre><code>is_uv_available() -&gt; bool\n</code></pre> <p>Check if <code>uv</code> is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>uv</code> is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import is_uv_available\n&gt;&gt;&gt; is_uv_available()\n</code></pre>"},{"location":"refs/package/","title":"Package","text":""},{"location":"refs/package/#feu.package","title":"feu.package","text":"<p>Contain functions to check a package configuration.</p>"},{"location":"refs/package/#feu.package.PackageConfig","title":"feu.package.PackageConfig","text":"<p>Implement the main package config registry.</p>"},{"location":"refs/package/#feu.package.PackageConfig.add_config","title":"feu.package.PackageConfig.add_config  <code>classmethod</code>","text":"<pre><code>add_config(\n    pkg_name: str,\n    pkg_version_min: str | None,\n    pkg_version_max: str | None,\n    python_version: str,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a new package configuration.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>pkg_version_min</code> <code>str | None</code> <p>The minimum valid package version for this configuration. <code>None</code> means there is no minimum valid package version.</p> required <code>pkg_version_max</code> <code>str | None</code> <p>The maximum valid package version for this configuration. <code>None</code> means there is no maximum valid package version.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if a package configuration already exists. This parameter should be  set to <code>True</code> to overwrite the package configuration.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a package configuration is already registered and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import PackageConfig\n&gt;&gt;&gt; PackageConfig.add_config(\n...     pkg_name=\"my_package\",\n...     python_version=\"3.11\",\n...     pkg_version_min=\"1.2.0\",\n...     pkg_version_max=\"2.0.2\",\n...     exist_ok=True,\n... )\n</code></pre>"},{"location":"refs/package/#feu.package.PackageConfig.find_closest_version","title":"feu.package.PackageConfig.find_closest_version  <code>classmethod</code>","text":"<pre><code>find_closest_version(\n    pkg_name: str, pkg_version: str, python_version: str\n) -&gt; str\n</code></pre> <p>Find the closest valid version given the package name and version, and python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>pkg_version</code> <code>str</code> <p>The package version to check.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The closest valid version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import PackageConfig\n&gt;&gt;&gt; PackageConfig.find_closest_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"2.0.2\",\n...     python_version=\"3.11\",\n... )\n2.0.2\n&gt;&gt;&gt; PackageConfig.find_closest_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"1.0.2\",\n...     python_version=\"3.11\",\n... )\n1.23.2\n</code></pre>"},{"location":"refs/package/#feu.package.PackageConfig.get_config","title":"feu.package.PackageConfig.get_config  <code>classmethod</code>","text":"<pre><code>get_config(\n    pkg_name: str, python_version: str\n) -&gt; dict[str, str | None]\n</code></pre> <p>Get a package configuration given the package name and python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>dict[str, str | None]</code> <p>The package configuration.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import PackageConfig\n&gt;&gt;&gt; PackageConfig.get_config(\n...     pkg_name=\"numpy\",\n...     python_version=\"3.11\",\n... )\n{'min': '1.23.2', 'max': None}\n</code></pre>"},{"location":"refs/package/#feu.package.PackageConfig.get_min_and_max_versions","title":"feu.package.PackageConfig.get_min_and_max_versions  <code>classmethod</code>","text":"<pre><code>get_min_and_max_versions(\n    pkg_name: str, python_version: str\n) -&gt; tuple[Version | None, Version | None]\n</code></pre> <p>Get the minimum and maximum versions for the given package name and python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>tuple[Version | None, Version | None]</code> <p>A tuple with the minimum and maximum versions. The version is set to <code>None</code> if there is no minimum or maximum version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import PackageConfig\n&gt;&gt;&gt; PackageConfig.get_min_and_max_versions(\n...     pkg_name=\"numpy\",\n...     python_version=\"3.11\",\n... )\n(&lt;Version('1.23.2')&gt;, None)\n</code></pre>"},{"location":"refs/package/#feu.package.PackageConfig.is_valid_version","title":"feu.package.PackageConfig.is_valid_version  <code>classmethod</code>","text":"<pre><code>is_valid_version(\n    pkg_name: str, pkg_version: str, python_version: str\n) -&gt; bool\n</code></pre> <p>Indicate if the specified package version is valid for the given Python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>pkg_version</code> <code>str</code> <p>The package version to check.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the specified package version is valid for the given Python version, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import PackageConfig\n&gt;&gt;&gt; PackageConfig.is_valid_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"2.0.2\",\n...     python_version=\"3.11\",\n... )\nTrue\n&gt;&gt;&gt; PackageConfig.is_valid_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"1.0.2\",\n...     python_version=\"3.11\",\n... )\nFalse\n</code></pre>"},{"location":"refs/package/#feu.package.find_closest_version","title":"feu.package.find_closest_version","text":"<pre><code>find_closest_version(\n    pkg_name: str, pkg_version: str, python_version: str\n) -&gt; str\n</code></pre> <p>Find the closest valid version given the package name and version, and python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>pkg_version</code> <code>str</code> <p>The package version to check.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The closest valid version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import find_closest_version\n&gt;&gt;&gt; find_closest_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"2.0.2\",\n...     python_version=\"3.11\",\n... )\n2.0.2\n&gt;&gt;&gt; find_closest_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"1.0.2\",\n...     python_version=\"3.11\",\n... )\n1.23.2\n</code></pre>"},{"location":"refs/package/#feu.package.is_valid_version","title":"feu.package.is_valid_version","text":"<pre><code>is_valid_version(\n    pkg_name: str, pkg_version: str, python_version: str\n) -&gt; bool\n</code></pre> <p>Indicate if the specified package version is valid for the given Python version.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The package name.</p> required <code>pkg_version</code> <code>str</code> <p>The package version to check.</p> required <code>python_version</code> <code>str</code> <p>The python version.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the specified package version is valid for the given Python version, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.package import is_valid_version\n&gt;&gt;&gt; is_valid_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"2.0.2\",\n...     python_version=\"3.11\",\n... )\nTrue\n&gt;&gt;&gt; is_valid_version(\n...     pkg_name=\"numpy\",\n...     pkg_version=\"1.0.2\",\n...     python_version=\"3.11\",\n... )\nFalse\n</code></pre>"},{"location":"refs/repo/","title":"Repository","text":""},{"location":"refs/repo/#feu.repo","title":"feu.repo","text":"<p>Contain functions to manage repos.</p>"},{"location":"refs/repo/#feu.repo.fetch_github_metadata","title":"feu.repo.fetch_github_metadata  <code>cached</code>","text":"<pre><code>fetch_github_metadata(\n    owner: str, repo: str\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the GitHub repo metadata.</p> <p>The metadata is read from GitHub API.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The repo name.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The repo metadata.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.repo import fetch_github_metadata\n&gt;&gt;&gt; metadata = fetch_github_metadata(owner=\"durandtibo\", repo=\"feu\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/root/","title":"Main functions","text":""},{"location":"refs/root/#feu","title":"feu","text":"<p>Root package of <code>feu</code>.</p>"},{"location":"refs/root/#feu.compare_version","title":"feu.compare_version","text":"<pre><code>compare_version(\n    package: str, op: Callable, version: str\n) -&gt; bool\n</code></pre> <p>Compare a package version to a given version.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package to check.</p> required <code>op</code> <code>Callable</code> <p>The comparison operator.</p> required <code>version</code> <code>str</code> <p>The version to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The comparison status.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; from feu.version import compare_version\n&gt;&gt;&gt; compare_version(\"pytest\", op=operator.ge, version=\"7.3.0\")\nTrue\n</code></pre>"},{"location":"refs/root/#feu.get_package_version","title":"feu.get_package_version","text":"<pre><code>get_package_version(package: str) -&gt; Version | None\n</code></pre> <p>Get the package version.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <p>Returns:</p> Type Description <code>Version | None</code> <p>The package version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import get_package_version\n&gt;&gt;&gt; get_package_version(\"pytest\")\n&lt;Version('...')&gt;\n</code></pre>"},{"location":"refs/root/#feu.install_package","title":"feu.install_package","text":"<pre><code>install_package(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package with the specified installer.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/root/#feu.install_package_closest_version","title":"feu.install_package_closest_version","text":"<pre><code>install_package_closest_version(\n    installer: InstallerSpec, package: PackageSpec\n) -&gt; None\n</code></pre> <p>Install a package and associated packages by using the secified installer.</p> <p>This function finds the closest valid version if the specified version is not compatible.</p> <p>Parameters:</p> Name Type Description Default <code>installer</code> <code>InstallerSpec</code> <p>The installer specification.</p> required <code>package</code> <code>PackageSpec</code> <p>The package specification.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no package version is specified.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.install import install_package_closest_version\n&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; install_package_closest_version(\n...     installer=InstallerSpec(\"pip\"), package=PackageSpec(name=\"pandas\", version=\"2.2.2\")\n... )  # doctest: +SKIP\n</code></pre>"},{"location":"refs/root/#feu.is_module_available","title":"feu.is_module_available  <code>cached</code>","text":"<pre><code>is_module_available(module: str) -&gt; bool\n</code></pre> <p>Check if a module path is available.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>str</code> <p>The module to check.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu import is_module_available\n&gt;&gt;&gt; is_module_available(\"os\")\nTrue\n&gt;&gt;&gt; is_module_available(\"os.path\")\nTrue\n&gt;&gt;&gt; is_module_available(\"missing.module\")\nFalse\n</code></pre>"},{"location":"refs/root/#feu.is_package_available","title":"feu.is_package_available  <code>cached</code>","text":"<pre><code>is_package_available(package: str) -&gt; bool\n</code></pre> <p>Check if a package is available.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the package is available, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu import is_package_available\n&gt;&gt;&gt; is_package_available(\"os\")\nTrue\n&gt;&gt;&gt; is_package_available(\"os.path\")\nTrue\n&gt;&gt;&gt; is_package_available(\"my_missing_package\")\nFalse\n</code></pre>"},{"location":"refs/testing/","title":"Testing","text":""},{"location":"refs/testing/#feu.testing","title":"feu.testing","text":"<p>Define some utility functions for testing.</p>"},{"location":"refs/utils/","title":"Utils","text":""},{"location":"refs/utils/#feu.utils","title":"feu.utils","text":"<p>Contain the utility functions.</p>"},{"location":"refs/utils/#feu.utils.command","title":"feu.utils.command","text":"<p>Contain utility functions to run commands.</p>"},{"location":"refs/utils/#feu.utils.command.run_bash_command","title":"feu.utils.command.run_bash_command","text":"<pre><code>run_bash_command(cmd: str) -&gt; None\n</code></pre> <p>Execute a bash command.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The command to run.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.command import run_bash_command\n&gt;&gt;&gt; run_bash_command(\"ls -l\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/utils/#feu.utils.installer","title":"feu.utils.installer","text":"<p>Contain utility functions to manage installers.</p>"},{"location":"refs/utils/#feu.utils.installer.InstallerSpec","title":"feu.utils.installer.InstallerSpec  <code>dataclass</code>","text":"<p>Define a dataclass to represent an installer specification.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The installer name.</p> required <code>arguments</code> <code>str</code> <p>A string containing optional installer arguments.</p> <code>''</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.installer import InstallerSpec\n&gt;&gt;&gt; installer1 = InstallerSpec(\"pip\")\n&gt;&gt;&gt; installer1\nInstallerSpec(name='pip', arguments='')\n&gt;&gt;&gt; installer2 = InstallerSpec(\"pip\", arguments=\"-U\")\n&gt;&gt;&gt; installer2\nInstallerSpec(name='pip', arguments='-U')\n</code></pre>"},{"location":"refs/utils/#feu.utils.package","title":"feu.utils.package","text":"<p>Contain utility functions to manage packages.</p>"},{"location":"refs/utils/#feu.utils.package.PackageDependency","title":"feu.utils.package.PackageDependency  <code>dataclass</code>","text":"<p>Define a dataclass to represent a package dependency.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The package name.</p> required <code>version_specifiers</code> <code>list[str] | None</code> <p>Optional package version specifies.</p> <code>None</code> <code>extras</code> <code>list[str] | None</code> <p>Optional package extra dependencies.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import PackageDependency\n&gt;&gt;&gt; pkg1 = PackageDependency(\"my_package\")\n&gt;&gt;&gt; pkg1\nPackageDependency(name='my_package', version_specifiers=None, extras=None)\n&gt;&gt;&gt; pkg2 = PackageDependency(\"my_package\", version_specifiers=[\"==1.2.3\"])\n&gt;&gt;&gt; pkg2\nPackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=None)\n&gt;&gt;&gt; pkg3 = PackageDependency(\n...     \"my_package\", version_specifiers=[\"==1.2.3\"], extras=[\"security\", \"socks\"]\n... )\n&gt;&gt;&gt; pkg3\nPackageDependency(name='my_package', version_specifiers=['==1.2.3'], extras=['security', 'socks'])\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.PackageSpec","title":"feu.utils.package.PackageSpec  <code>dataclass</code>","text":"<p>Define a dataclass to represent a package specification.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The package name.</p> required <code>version</code> <code>str | None</code> <p>An optional package version.</p> <code>None</code> <code>extras</code> <code>list[str] | None</code> <p>Optional package extra dependencies.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; pkg1 = PackageSpec(\"my_package\")\n&gt;&gt;&gt; pkg1\nPackageSpec(name='my_package', version=None, extras=None)\n&gt;&gt;&gt; pkg2 = PackageSpec(\"my_package\", version=\"1.2.3\")\n&gt;&gt;&gt; pkg2\nPackageSpec(name='my_package', version='1.2.3', extras=None)\n&gt;&gt;&gt; pkg3 = PackageSpec(\"my_package\", version=\"1.2.3\", extras=[\"security\", \"socks\"])\n&gt;&gt;&gt; pkg3\nPackageSpec(name='my_package', version='1.2.3', extras=['security', 'socks'])\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.PackageSpec.to_package_dependency","title":"feu.utils.package.PackageSpec.to_package_dependency","text":"<pre><code>to_package_dependency() -&gt; PackageDependency\n</code></pre> <p>Convert to a <code>PackageDependency</code>.</p> <p>Returns:</p> Type Description <code>PackageDependency</code> <p>The current package as a package dependency.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; pkg = PackageSpec(\"my_package\")\n&gt;&gt;&gt; dep = pkg.to_package_dependency()\n&gt;&gt;&gt; dep\nPackageDependency(name='my_package', version_specifiers=None, extras=None)\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.PackageSpec.with_version","title":"feu.utils.package.PackageSpec.with_version","text":"<pre><code>with_version(version: str | None) -&gt; PackageSpec\n</code></pre> <p>Create a new <code>PackageSpec</code> instance with the given version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str | None</code> <p>The new version to apply.</p> required <p>Returns:</p> Type Description <code>PackageSpec</code> <p>A new instance of PackageSpec with the updated version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import PackageSpec\n&gt;&gt;&gt; pkg = PackageSpec(\"my_package\", version=\"1.2.0\")\n&gt;&gt;&gt; pkg\nPackageSpec(name='my_package', version='1.2.0', extras=None)\n&gt;&gt;&gt; pkg2 = pkg.with_version(\"1.2.3\")\n&gt;&gt;&gt; pkg2\nPackageSpec(name='my_package', version='1.2.3', extras=None)\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.extract_package_extras","title":"feu.utils.package.extract_package_extras","text":"<pre><code>extract_package_extras(requirement: str) -&gt; list[str]\n</code></pre> <p>Extract the optional extras from a requirement string.</p> <p>The requirement string may include extras in square brackets, e.g., 'package[extra1,extra2]'. This function returns the list of extras.</p> <p>Parameters:</p> Name Type Description Default <code>requirement</code> <code>str</code> <p>The requirement string containing the package name and optionally extra dependencies.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of extra requirements, or an empty list if none exist.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import extract_package_extras\n&gt;&gt;&gt; extract_package_extras(\"numpy\")\n[]\n&gt;&gt;&gt; extract_package_extras(\"pandas[performance]\")\n['performance']\n&gt;&gt;&gt; extract_package_extras(\"requests[security,socks]\")\n['security', 'socks']\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.extract_package_name","title":"feu.utils.package.extract_package_name","text":"<pre><code>extract_package_name(requirement: str) -&gt; str\n</code></pre> <p>Extract the base package name from a requirement string.</p> <p>The requirement string may include optional dependencies in square brackets, such as 'package[extra1,extra2]'. This function returns only the base package name without the extras.</p> <p>Parameters:</p> Name Type Description Default <code>requirement</code> <code>str</code> <p>The requirement string containing the package name and optionally extra dependencies.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The base package name without extras.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import extract_package_name\n&gt;&gt;&gt; extract_package_name(\"numpy\")\n'numpy'\n&gt;&gt;&gt; extract_package_name(\"pandas[performance]\")\n'pandas'\n&gt;&gt;&gt; extract_package_name(\"requests[security,socks]\")\n'requests'\n</code></pre>"},{"location":"refs/utils/#feu.utils.package.generate_extras_string","title":"feu.utils.package.generate_extras_string","text":"<pre><code>generate_extras_string(extras: Sequence[str]) -&gt; str\n</code></pre> <p>Generate a string with the package extras i.e. optional dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>Sequence[str]</code> <p>The package optional dependencies.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string with the package extras.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.utils.package import generate_extras_string\n&gt;&gt;&gt; generate_extras_string([\"security\"])\n'[security]'\n&gt;&gt;&gt; generate_extras_string([\"security\", \"socks\"])\n'[security,socks]'\n&gt;&gt;&gt; generate_extras_string([])\n''\n</code></pre>"},{"location":"refs/version/","title":"Version","text":""},{"location":"refs/version/#feu.version","title":"feu.version","text":"<p>Contain functions to manage package versions.</p>"},{"location":"refs/version/#feu.version.compare_version","title":"feu.version.compare_version","text":"<pre><code>compare_version(\n    package: str, op: Callable, version: str\n) -&gt; bool\n</code></pre> <p>Compare a package version to a given version.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package to check.</p> required <code>op</code> <code>Callable</code> <p>The comparison operator.</p> required <code>version</code> <code>str</code> <p>The version to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The comparison status.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; from feu.version import compare_version\n&gt;&gt;&gt; compare_version(\"pytest\", op=operator.ge, version=\"7.3.0\")\nTrue\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_latest_major_versions","title":"feu.version.fetch_latest_major_versions","text":"<pre><code>fetch_latest_major_versions(\n    package: str,\n    lower: str | None = None,\n    upper: str | None = None,\n) -&gt; tuple[str, ...]\n</code></pre> <p>Get the latest version for each major version for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <code>lower</code> <code>str | None</code> <p>The lower version bound (inclusive). If <code>None</code>, no lower limit is applied.</p> <code>None</code> <code>upper</code> <code>str | None</code> <p>The upper version bound (exclusive). If None, no upper limit is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple containing the latest version for each major version, sorted by major version number.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_latest_major_versions\n&gt;&gt;&gt; versions = fetch_latest_major_versions(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_latest_minor_versions","title":"feu.version.fetch_latest_minor_versions","text":"<pre><code>fetch_latest_minor_versions(\n    package: str,\n    lower: str | None = None,\n    upper: str | None = None,\n) -&gt; tuple[str, ...]\n</code></pre> <p>Get the latest version for each minor version for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <code>lower</code> <code>str | None</code> <p>The lower version bound (inclusive). If <code>None</code>, no lower limit is applied.</p> <code>None</code> <code>upper</code> <code>str | None</code> <p>The upper version bound (exclusive). If None, no upper limit is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple containing the latest version for each minor version, sorted by minor version number.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_latest_minor_versions\n&gt;&gt;&gt; versions = fetch_latest_minor_versions(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_latest_stable_version","title":"feu.version.fetch_latest_stable_version","text":"<pre><code>fetch_latest_stable_version(package: str) -&gt; str\n</code></pre> <p>Get the latest stable valid versions for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The latest stable valid versions.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_latest_stable_version\n&gt;&gt;&gt; version = fetch_latest_stable_version(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_latest_version","title":"feu.version.fetch_latest_version","text":"<pre><code>fetch_latest_version(package: str) -&gt; str\n</code></pre> <p>Get the latest valid versions for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The latest valid versions.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_latest_version\n&gt;&gt;&gt; version = fetch_latest_version(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_pypi_versions","title":"feu.version.fetch_pypi_versions  <code>cached</code>","text":"<pre><code>fetch_pypi_versions(\n    package: str, reverse: bool = False\n) -&gt; tuple[str, ...]\n</code></pre> <p>Get the package versions available on PyPI.</p> <p>The package versions are read from PyPI.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <code>reverse</code> <code>bool</code> <p>If <code>False</code>, sort in ascending order; if <code>True</code>, sort in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A list containing the sorted version strings.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_pypi_versions\n&gt;&gt;&gt; versions = fetch_pypi_versions(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.fetch_versions","title":"feu.version.fetch_versions","text":"<pre><code>fetch_versions(\n    package: str,\n    lower: str | None = None,\n    upper: str | None = None,\n) -&gt; tuple[str, ...]\n</code></pre> <p>Get the valid versions for a given package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <code>lower</code> <code>str | None</code> <p>The lower version bound (inclusive). If <code>None</code>, no lower limit is applied.</p> <code>None</code> <code>upper</code> <code>str | None</code> <p>The upper version bound (exclusive). If None, no upper limit is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple containing the valid versions.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import fetch_versions\n&gt;&gt;&gt; versions = fetch_versions(\"requests\")  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.filter_every_n_versions","title":"feu.version.filter_every_n_versions","text":"<pre><code>filter_every_n_versions(\n    versions: Sequence[str], n: int\n) -&gt; list[str]\n</code></pre> <p>Filter a list of version strings, keeping only every n-th version using 0-based indexing.</p> <p>This function preserves the original order of the input list and returns a new list containing only the versions at positions that are multiples of <code>n</code> (using 0-based indexing). For example, if <code>n = 2</code>, the function keeps the 0th, 2nd, 4th, ... versions from the list.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <code>n</code> <code>int</code> <p>The interval for selecting versions. Must be &gt;= 1.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A new list containing only every n-th version in <code>versions</code>, starting from index 0.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>n</code> is less than 1.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import filter_every_n_versions\n&gt;&gt;&gt; versions = filter_every_n_versions([\"1.0\", \"1.1\", \"1.2\", \"1.3\", \"1.5\", \"1.6\"], n=2)\n&gt;&gt;&gt; versions\n['1.0', '1.2', '1.5']\n&gt;&gt;&gt; versions = filter_every_n_versions([\"1.0\", \"1.1\", \"1.2\", \"1.3\", \"1.5\", \"1.6\"], n=1)\n&gt;&gt;&gt; versions\n['1.0', '1.1', '1.2', '1.3', '1.5', '1.6']\n</code></pre>"},{"location":"refs/version/#feu.version.filter_last_n_versions","title":"feu.version.filter_last_n_versions","text":"<pre><code>filter_last_n_versions(\n    versions: Sequence[str], n: int\n) -&gt; list[str]\n</code></pre> <p>Return only the last n versions from a list of version strings.</p> <p>This function preserves the original ordering of the final n elements. If <code>n</code> is greater than the number of versions available, the entire list is returned. If <code>n</code> is zero, an empty list is returned.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <code>n</code> <code>int</code> <p>Number of versions to keep from the end of the list. Must be &gt;= 0.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A new list containing only the last n versions, in order.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>n</code> is less than 1.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import filter_last_n_versions\n&gt;&gt;&gt; versions = filter_last_n_versions([\"1.0\", \"1.1\", \"1.2\", \"1.3\"], n=2)\n&gt;&gt;&gt; versions\n['1.2', '1.3']\n&gt;&gt;&gt; versions = filter_last_n_versions([\"1.0\", \"1.1\", \"1.2\", \"1.3\"], n=5)\n&gt;&gt;&gt; versions\n['1.0', '1.1', '1.2', '1.3']\n</code></pre>"},{"location":"refs/version/#feu.version.filter_range_versions","title":"feu.version.filter_range_versions","text":"<pre><code>filter_range_versions(\n    versions: Sequence[str],\n    lower: str | None = None,\n    upper: str | None = None,\n) -&gt; list[str]\n</code></pre> <p>Filter a list of version strings to include only versions within optional bounds.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <code>lower</code> <code>str | None</code> <p>The lower version bound (inclusive). If <code>None</code>, no lower limit is applied.</p> <code>None</code> <code>upper</code> <code>str | None</code> <p>The upper version bound (exclusive). If None, no upper limit is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of version strings that fall within the specified bounds.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import filter_range_versions\n&gt;&gt;&gt; versions = filter_range_versions(\n...     [\"1.0.0\", \"1.2.0\", \"1.3.0\", \"2.0.0\"], lower=\"1.1.0\", upper=\"2.0.0\"\n... )\n&gt;&gt;&gt; versions\n['1.2.0', '1.3.0']\n&gt;&gt;&gt; versions = filter_range_versions([\"0.9.0\", \"1.0.0\", \"1.1.0\"], lower=\"1.0.0\")\n&gt;&gt;&gt; versions\n['1.0.0', '1.1.0']\n</code></pre>"},{"location":"refs/version/#feu.version.filter_stable_versions","title":"feu.version.filter_stable_versions","text":"<pre><code>filter_stable_versions(\n    versions: Sequence[str],\n) -&gt; list[str]\n</code></pre> <p>Filter out pre-release, post-release, and dev-release versions from a list of version strings.</p> A stable version is defined as <ul> <li>Not a pre-release (e.g., alpha <code>a</code>, beta <code>b</code>, release candidate <code>rc</code>)</li> <li>Not a post-release (e.g., <code>1.0.0.post1</code>)</li> <li>Not a development release (e.g., <code>1.0.0.dev1</code>)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list containing only stable version strings.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import filter_stable_versions\n&gt;&gt;&gt; versions = filter_stable_versions(\n...     [\"1.0.0\", \"1.0.0a1\", \"2.0.0\", \"2.0.0.dev1\", \"3.0.0.post1\"]\n... )\n&gt;&gt;&gt; versions\n['1.0.0', '2.0.0']\n</code></pre>"},{"location":"refs/version/#feu.version.filter_valid_versions","title":"feu.version.filter_valid_versions","text":"<pre><code>filter_valid_versions(versions: Sequence[str]) -&gt; list[str]\n</code></pre> <p>Filter out invalid version strings based on PEP 440.</p> <p>A valid version is one that can be parsed by <code>packaging.version.Version</code>. Invalid versions include strings that don't conform to semantic versioning rules.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list containing only valid version strings.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import filter_valid_versions\n&gt;&gt;&gt; versions = filter_valid_versions(\n...     [\n...         \"1.0.0\",\n...         \"1.0.0a1\",\n...         \"2.0.0.post1\",\n...         \"not-a-version\",\n...         \"\",\n...         \"2\",\n...         \"3.0\",\n...         \"v1.0.0\",\n...         \"1.0.0.0.0\",\n...         \"4.0.0.dev1\",\n...     ]\n... )\n&gt;&gt;&gt; versions\n['1.0.0', '1.0.0a1', '2.0.0.post1', '2', '3.0', 'v1.0.0', '1.0.0.0.0', '4.0.0.dev1']\n</code></pre>"},{"location":"refs/version/#feu.version.get_package_version","title":"feu.version.get_package_version","text":"<pre><code>get_package_version(package: str) -&gt; Version | None\n</code></pre> <p>Get the package version.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <p>Returns:</p> Type Description <code>Version | None</code> <p>The package version.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import get_package_version\n&gt;&gt;&gt; get_package_version(\"pytest\")\n&lt;Version('...')&gt;\n</code></pre>"},{"location":"refs/version/#feu.version.get_python_major_minor","title":"feu.version.get_python_major_minor  <code>cached</code>","text":"<pre><code>get_python_major_minor() -&gt; str\n</code></pre> <p>Get the MAJOR.MINOR version of the current python.</p> <p>Returns:</p> Type Description <code>str</code> <p>The MAJOR.MINOR version of the current python.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import get_python_major_minor\n&gt;&gt;&gt; get_python_major_minor()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/version/#feu.version.latest_major_versions","title":"feu.version.latest_major_versions","text":"<pre><code>latest_major_versions(versions: Sequence[str]) -&gt; list[str]\n</code></pre> <p>Return the latest version for each major version in a list of semantic versions.</p> <p>This function takes a list of semantic version strings (e.g. \"1.0.0\", \"1.2.1\", \"2.0.0\"), groups them by their major version number, and returns only the latest version from each major group (based on minor and patch numbers).</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings in semantic version format.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list containing the latest version for each major version, sorted by major version number.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import latest_major_versions\n&gt;&gt;&gt; versions = latest_major_versions([\"1.0.0\", \"1.1.0\", \"1.2.0\", \"1.2.1\", \"2.0.0\"])\n&gt;&gt;&gt; versions\n['1.2.1', '2.0.0']\n</code></pre>"},{"location":"refs/version/#feu.version.latest_minor_versions","title":"feu.version.latest_minor_versions","text":"<pre><code>latest_minor_versions(versions: Sequence[str]) -&gt; list[str]\n</code></pre> <p>Return the latest version for each minor version in a list of semantic versions.</p> <p>This function takes a list of semantic version strings (e.g. \"1.0.0\", \"1.0.1\", \"1.1.0\", \"2.0.0\"), groups them by their major and minor version numbers, and returns only the latest version from each minor group (based on the patch number).</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings in semantic version format.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list containing the latest version for each minor version, sorted by major and minor version numbers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import latest_major_versions\n&gt;&gt;&gt; versions = latest_minor_versions([\"1.0.0\", \"1.0.1\", \"1.1.0\", \"1.1.2\", \"2.0.0\", \"2.0.3\"])\n&gt;&gt;&gt; versions\n['1.0.1', '1.1.2', '2.0.3']\n</code></pre>"},{"location":"refs/version/#feu.version.latest_version","title":"feu.version.latest_version","text":"<pre><code>latest_version(versions: Sequence[str]) -&gt; str\n</code></pre> <p>Return the latest version string in a list of version identifiers.</p> <p>This function compares version strings according to the PEP 440 specification using :class:<code>packaging.version.Version</code>. It supports standard releases, pre-releases (alpha, beta, release candidates), development releases, post releases, and epoch-based versions.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings to compare.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The highest (latest) version in the list based on PEP 440 ordering.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>versions</code> is empty.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; from feu.version import latest_version\n&gt;&gt;&gt; latest_version([\"1.0.0\", \"1.0.1rc1\", \"1.0.1\"])\n'1.0.1'\n&gt;&gt;&gt; latest_version([\"1.2.0\", \"2.0.0a1\"])\n'2.0.0a1'\n</code></pre>"},{"location":"refs/version/#feu.version.sort_versions","title":"feu.version.sort_versions","text":"<pre><code>sort_versions(\n    versions: Sequence[str], reverse: bool = False\n) -&gt; list[str]\n</code></pre> <p>Sort a list of version strings in ascending or descending order.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <code>reverse</code> <code>bool</code> <p>If <code>False</code>, sort in ascending order; if <code>True</code>, sort in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A new list of version strings sorted according to semantic version order.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; from feu.version import sort_versions\n&gt;&gt;&gt; sort_versions([\"1.0.0\", \"1.2.0\", \"1.1.0\"])\n['1.0.0', '1.1.0', '1.2.0']\n&gt;&gt;&gt; sort_versions([\"1.0.0\", \"1.2.0\", \"1.1.0\"], reverse=True)\n['1.2.0', '1.1.0', '1.0.0']\n</code></pre>"},{"location":"refs/version/#feu.version.unique_versions","title":"feu.version.unique_versions","text":"<pre><code>unique_versions(versions: Sequence[str]) -&gt; list[str]\n</code></pre> <p>Return a list of unique versions while preserving order.</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Sequence[str]</code> <p>A list of version strings.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list containing only unique version strings, preserving the original order of first occurrence.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from feu.version import unique_versions, sort_versions\n&gt;&gt;&gt; versions = sort_versions(unique_versions([\"1.0.0\", \"1.0.1\", \"1.0.0\", \"1.2.0\"]))\n&gt;&gt;&gt; versions\n['1.0.0', '1.0.1', '1.2.0']\n</code></pre>"}]}